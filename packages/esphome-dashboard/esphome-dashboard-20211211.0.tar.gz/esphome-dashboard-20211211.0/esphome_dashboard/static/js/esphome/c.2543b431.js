import{_ as e,e as t,j as r,a as i,y as a,h as s,k as o,l as n,r as c,n as l}from"./index-6b4dee4b.js";import{C as h,c as d,d as g,e as p,t as m,f as u,g as f,E as y,D as w,M as _,R as b,h as I,i as k,S as $,j as v,k as S,l as B,n as F,o as C,p as D,q as R,r as z,F as U,u as x,v as E,w as T,x as A,y as L,z as P,A as V,B as M,G as W,H as O,I as j,J as N,K as q,L as H,N as Q,O as G,P as J,Q as K,T as X,U as Y,V as Z,W as ee,X as te,Y as re,Z as ie,_ as ae,$ as se,a0 as oe,a1 as ne,a2 as ce,a3 as le}from"./c.56258c5a.js";import{g as he,a as de}from"./c.423f4a55.js";class ge extends i{constructor(){super(...arguments),this.indeterminate=!1,this.progress=0,this.density=0,this.closed=!1}open(){this.closed=!1}close(){this.closed=!0}render(){const e={"mdc-circular-progress--closed":this.closed,"mdc-circular-progress--indeterminate":this.indeterminate},t=48+4*this.density,r={width:`${t}px`,height:`${t}px`};return a`
      <div
        class="mdc-circular-progress ${s(e)}"
        style="${o(r)}"
        role="progressbar"
        aria-label="${n(this.ariaLabel)}"
        aria-valuemin="0"
        aria-valuemax="1"
        aria-valuenow="${n(this.indeterminate?void 0:this.progress)}">
        ${this.renderDeterminateContainer()}
        ${this.renderIndeterminateContainer()}
      </div>`}renderDeterminateContainer(){const e=48+4*this.density,t=e/2,r=this.density>=-3?18+11*this.density/6:12.5+5*(this.density+3)/4,i=6.2831852*r,s=(1-this.progress)*i,o=this.density>=-3?4+this.density*(1/3):3+(this.density+3)*(1/6);return a`
      <div class="mdc-circular-progress__determinate-container">
        <svg class="mdc-circular-progress__determinate-circle-graphic"
             viewBox="0 0 ${e} ${e}">
          <circle class="mdc-circular-progress__determinate-track"
                  cx="${t}" cy="${t}" r="${r}"
                  stroke-width="${o}"></circle>
          <circle class="mdc-circular-progress__determinate-circle"
                  cx="${t}" cy="${t}" r="${r}"
                  stroke-dasharray="${6.2831852*r}"
                  stroke-dashoffset="${s}"
                  stroke-width="${o}"></circle>
        </svg>
      </div>`}renderIndeterminateContainer(){return a`
      <div class="mdc-circular-progress__indeterminate-container">
        <div class="mdc-circular-progress__spinner-layer">
          ${this.renderIndeterminateSpinnerLayer()}
        </div>
      </div>`}renderIndeterminateSpinnerLayer(){const e=48+4*this.density,t=e/2,r=this.density>=-3?18+11*this.density/6:12.5+5*(this.density+3)/4,i=6.2831852*r,s=.5*i,o=this.density>=-3?4+this.density*(1/3):3+(this.density+3)*(1/6);return a`
        <div class="mdc-circular-progress__circle-clipper mdc-circular-progress__circle-left">
          <svg class="mdc-circular-progress__indeterminate-circle-graphic"
               viewBox="0 0 ${e} ${e}">
            <circle cx="${t}" cy="${t}" r="${r}"
                    stroke-dasharray="${i}"
                    stroke-dashoffset="${s}"
                    stroke-width="${o}"></circle>
          </svg>
        </div>
        <div class="mdc-circular-progress__gap-patch">
          <svg class="mdc-circular-progress__indeterminate-circle-graphic"
               viewBox="0 0 ${e} ${e}">
            <circle cx="${t}" cy="${t}" r="${r}"
                    stroke-dasharray="${i}"
                    stroke-dashoffset="${s}"
                    stroke-width="${.8*o}"></circle>
          </svg>
        </div>
        <div class="mdc-circular-progress__circle-clipper mdc-circular-progress__circle-right">
          <svg class="mdc-circular-progress__indeterminate-circle-graphic"
               viewBox="0 0 ${e} ${e}">
            <circle cx="${t}" cy="${t}" r="${r}"
                    stroke-dasharray="${i}"
                    stroke-dashoffset="${s}"
                    stroke-width="${o}"></circle>
          </svg>
        </div>`}update(e){super.update(e),e.has("progress")&&(this.progress>1&&(this.progress=1),this.progress<0&&(this.progress=0))}}e([t({type:Boolean,reflect:!0})],ge.prototype,"indeterminate",void 0),e([t({type:Number,reflect:!0})],ge.prototype,"progress",void 0),e([t({type:Number,reflect:!0})],ge.prototype,"density",void 0),e([t({type:Boolean,reflect:!0})],ge.prototype,"closed",void 0),e([r,t({type:String,attribute:"aria-label"})],ge.prototype,"ariaLabel",void 0);const pe=c`.mdc-circular-progress__determinate-circle,.mdc-circular-progress__indeterminate-circle-graphic{stroke:#6200ee;stroke:var(--mdc-theme-primary, #6200ee)}.mdc-circular-progress__determinate-track{stroke:transparent}@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-color-1-fade-in-out{from{opacity:.99}25%{opacity:.99}26%{opacity:0}89%{opacity:0}90%{opacity:.99}to{opacity:.99}}@keyframes mdc-circular-progress-color-2-fade-in-out{from{opacity:0}15%{opacity:0}25%{opacity:.99}50%{opacity:.99}51%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-3-fade-in-out{from{opacity:0}40%{opacity:0}50%{opacity:.99}75%{opacity:.99}76%{opacity:0}to{opacity:0}}@keyframes mdc-circular-progress-color-4-fade-in-out{from{opacity:0}65%{opacity:0}75%{opacity:.99}90%{opacity:.99}to{opacity:0}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}.mdc-circular-progress{display:inline-flex;position:relative;direction:ltr;line-height:0;transition:opacity 250ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:transparent}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-1{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-1-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-2{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-2-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-3{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-3-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__color-4{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both,mdc-circular-progress-color-4-fade-in-out 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--closed{opacity:0}:host{display:inline-flex}.mdc-circular-progress__determinate-track{stroke:transparent;stroke:var(--mdc-circular-progress-track-color, transparent)}`;let me=class extends ge{};me.styles=[pe],me=e([l("mwc-circular-progress")],me);const ue=async e=>{let t;return e==h?t=await import("./c.f082d0eb.js"):e==d?t=await import("./c.885868ea.js"):e==g?t=await import("./c.720c340b.js"):e==p&&(t=await import("./c.4cda624e.js")),{...t,text:m(atob(t.text)),data:m(atob(t.data))}},fe={b:{u:DataView.prototype.getInt8,p:DataView.prototype.setInt8,bytes:1},B:{u:DataView.prototype.getUint8,p:DataView.prototype.setUint8,bytes:1},h:{u:DataView.prototype.getInt16,p:DataView.prototype.setInt16,bytes:2},H:{u:DataView.prototype.getUint16,p:DataView.prototype.setUint16,bytes:2},i:{u:DataView.prototype.getInt32,p:DataView.prototype.setInt32,bytes:4},I:{u:DataView.prototype.getUint32,p:DataView.prototype.setUint32,bytes:4},q:{u:DataView.prototype.getInt64,p:DataView.prototype.setInt64,bytes:8},Q:{u:DataView.prototype.getUint64,p:DataView.prototype.setUint64,bytes:8}},ye=(e,...t)=>{let r=0;if(e.replace(/[<>]/,"").length!=t.length)throw"Pack format to Argument count mismatch";let i=[],a=!0;for(let i=0;i<e.length;i++)"<"==e[i]?a=!0:">"==e[i]?a=!1:(s(e[i],t[r]),r++);function s(e,t){if(!(e in fe))throw"Unhandled character '"+e+"' in pack format";let r=fe[e].bytes,s=new DataView(new ArrayBuffer(r));fe[e].p.bind(s)(0,t,a);for(let e=0;e<r;e++)i.push(s.getUint8(e))}return i},we=(e,t)=>{let r=0,i=[],a=!0;for(let t of e)"<"==t?a=!0:">"==t?a=!1:s(t);function s(e){if(!(e in fe))throw"Unhandled character '"+e+"' in unpack format";let s=fe[e].bytes,o=new DataView(new ArrayBuffer(s));for(let e=0;e<s;e++)o.setUint8(e,255&t[r+e]);let n=fe[e].u.bind(o);i.push(n(0,a)),r+=s}return i};class _e extends EventTarget{constructor(e,t,r){super(),this.port=e,this.logger=t,this._parent=r,this.chipName=null,this._efuses=new Array(4).fill(0),this._flashsize=4194304,this.debug=!1,this.IS_STUB=!1,this.connected=!0,this.flashSize=null}get _inputBuffer(){return this._parent?this._parent._inputBuffer:this.__inputBuffer}async initialize(){await this.hardReset(!0),this._parent||(this.__inputBuffer=[],this.readLoop()),await this.sync();let e,t=await this.readRegister(u),r=re[t>>>0];if(void 0===r)throw new Error(`Unknown Chip: Hex: ${f(t>>>0,8).toLowerCase()} Number: ${t}`);this.chipName=r.name,this.chipFamily=r.family,this.chipFamily==g?e=1072693328:this.chipFamily==h?e=1073061888:this.chipFamily==d&&(e=1610719232);for(let t=0;t<4;t++)this._efuses[t]=await this.readRegister(e+4*t);this.logger.log(`Chip type ${this.chipName}`)}async readLoop(){this.logger.debug("Starting read loop"),this._reader=this.port.readable.getReader();try{for(;;){const{value:e,done:t}=await this._reader.read();if(t){this._reader.releaseLock();break}e&&0!==e.length&&this._inputBuffer.push(...Array.from(e))}}catch(e){console.error("Read loop got disconnected")}this.connected=!1,this.dispatchEvent(new Event("disconnect")),this.logger.debug("Finished read loop")}async hardReset(e=!1){this.logger.log("Try hard reset."),await this.port.setSignals({dataTerminalReady:!1,requestToSend:!0}),await this.port.setSignals({dataTerminalReady:e,requestToSend:!1}),await new Promise((e=>setTimeout(e,1e3)))}macAddr(){let e,t=new Array(6).fill(0),r=this._efuses[0],i=this._efuses[1],a=this._efuses[2],s=this._efuses[3];if(this.chipFamily==g){if(0!=s)e=[s>>16&255,s>>8&255,255&s];else if(0==(i>>16&255))e=[24,254,52];else{if(1!=(i>>16&255))throw new Error("Couldnt determine OUI");e=[172,208,116]}t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=i>>8&255,t[4]=255&i,t[5]=r>>24&255}else if(this.chipFamily==h)t[0]=a>>8&255,t[1]=255&a,t[2]=i>>24&255,t[3]=i>>16&255,t[4]=i>>8&255,t[5]=255&i;else{if(this.chipFamily!=d)throw new Error("Unknown chip family");t[0]=a>>8&255,t[1]=255&a,t[2]=i>>24&255,t[3]=i>>16&255,t[4]=i>>8&255,t[5]=255&i}return t}async readRegister(e){this.debug&&this.logger.debug("Reading from Register "+f(e,8));let t=ye("<I",e);await this.sendCommand(y,t);let[r,i]=await this.getResponse(y);return r}async checkCommand(e,t,r=0,i=w){i=Math.min(i,_),await this.sendCommand(e,t,r);let[a,s]=await this.getResponse(e,i);if(null===s)throw new Error("Didn't get enough status bytes");let o=0;if(this.IS_STUB||this.chipFamily==g?o=2:[h,d].includes(this.chipFamily)?o=4:[2,4].includes(s.length)&&(o=s.length),s.length<o)throw new Error("Didn't get enough status bytes");let n=s.slice(-o,s.length);if(s=s.slice(0,-o),this.debug&&(this.logger.debug("status",n),this.logger.debug("value",a),this.logger.debug("data",s)),1==n[0])throw n[1]==b?new Error("Invalid (unsupported) command "+f(e)):new Error("Command failure error code "+f(n[1]));return[a,s]}async sendCommand(e,t,r=0){let i=I([...ye("<BBHI",0,e,t.length,r),...t]);this.debug&&this.logger.debug(`Writing ${i.length} byte${1==i.length?"":"s"}:`,i),await this.writeToStream(i)}async readPacket(e){let t=null,r=!1,i=[];for(;;){let a=Date.now();for(i=[];Date.now()-a<e;){if(this._inputBuffer.length>0){i.push(this._inputBuffer.shift());break}await k(10)}if(0==i.length){throw new $("Timed out waiting for packet "+(null===t?"header":"content"))}this.debug&&this.logger.debug("Read "+i.length+" bytes: "+v(i));for(let e of i)if(null===t){if(192!=e)throw this.debug&&(this.logger.debug("Read invalid data: "+v(i)),this.logger.debug("Remaining data in serial buffer: "+v(this._inputBuffer))),new $("Invalid head of packet ("+f(e)+")");t=[]}else if(r)if(r=!1,220==e)t.push(192);else{if(221!=e)throw this.debug&&(this.logger.debug("Read invalid data: "+v(i)),this.logger.debug("Remaining data in serial buffer: "+v(this._inputBuffer))),new $("Invalid SLIP escape (0xdb, "+f(e)+")");t.push(219)}else if(219==e)r=!0;else{if(192==e)return this.debug&&this.logger.debug("Received full packet: "+v(t)),t;t.push(e)}}throw new $("Invalid state")}async getResponse(e,t=w){for(let r=0;r<100;r++){const r=await this.readPacket(t);if(r.length<8)continue;const[i,a,s,o]=we("<BBHI",r.slice(0,8));if(1!=i)continue;const n=r.slice(8);if(null==e||a==e)return[o,n];if(0!=n[0]&&n[1]==b)throw this._inputBuffer.length=0,new Error(`Invalid (unsupported) command ${f(e)}`)}throw"Response doesn't match request"}checksum(e,t=S){for(let r of e)t^=r;return t}async setBaudrate(e){if(this.chipFamily==g)throw new Error("Changing baud rate is not supported on the ESP8266");this.logger.log("Attempting to change baud rate to "+e+"...");try{let t=ye("<II",e,this.IS_STUB?B:0);await this.checkCommand(F,t)}catch(t){throw console.error(t),new Error(`Unable to change the baud rate to ${e}: No response from set baud rate command.`)}this._parent?await this._parent.reconfigurePort(e):await this.reconfigurePort(e)}async reconfigurePort(e){var t;try{await(null===(t=this._reader)||void 0===t?void 0:t.cancel()),await this.port.close(),await this.port.open({baudRate:e}),this.readLoop(),this.logger.log(`Changed baud rate to ${e}`)}catch(t){throw console.error(t),new Error(`Unable to change the baud rate to ${e}: ${t}`)}}async sync(){for(let e=0;e<5;e++){if(this._inputBuffer.length=0,await this._sync())return await k(100),!0;await k(100)}throw new Error("Couldn't sync to ESP. Try resetting.")}async _sync(){await this.sendCommand(C,D);for(let e=0;e<8;e++)try{let[e,t]=await this.getResponse(C,R);if(t.length>1&&0==t[0]&&0==t[1])return!0}catch(e){}return!1}getFlashWriteSize(){return this.IS_STUB?z:U}async flashData(e,t,r=0,i=!1){this.updateImageFlashParams(r,e);let a,s=e.byteLength,o=0;i?(a=x(new Uint8Array(e),{level:9}).buffer,o=a.byteLength,this.logger.log(`Writing data with filesize: ${s}. Compressed Size: ${o}`),await this.flashDeflBegin(s,o,r)):(this.logger.log(`Writing data with filesize: ${s}`),a=e,await this.flashBegin(s,r));let n=[],c=0,l=0,h=0,d=Date.now(),g=this.getFlashWriteSize(),p=i?o:s;for(;p-h>0;)this.debug&&this.logger.log(`Writing at ${f(r+c*g,8)} `),p-h>=g?n=Array.from(new Uint8Array(a,h,g)):(n=Array.from(new Uint8Array(a,h,p-h)),i||(n=n.concat(new Array(g-n.length).fill(255)))),i?await this.flashDeflBlock(n,c):await this.flashBlock(n,c),c+=1,l+=i?Math.round(n.length*s/o):n.length,h+=g,t(l,p);this.logger.log("Took "+(Date.now()-d)+"ms to write "+p+" bytes"),this.IS_STUB&&(await this.flashBegin(0,0),i?await this.flashDeflFinish():await this.flashFinish())}async flashBlock(e,t,r=w){await this.checkCommand(E,ye("<IIII",e.length,t,0,0).concat(e),this.checksum(e),r)}async flashDeflBlock(e,t,r=w){await this.checkCommand(T,ye("<IIII",e.length,t,0,0).concat(e),this.checksum(e))}async flashBegin(e=0,t=0,r=!1){let i,a,s=this.getFlashWriteSize();!this.IS_STUB&&[h,d].includes(this.chipFamily)&&await this.checkCommand(A,new Array(8).fill(0)),this.chipFamily==h&&(a=ye("<IIIIII",0,this._flashsize,65536,4096,256,65535),await this.checkCommand(L,a));let o,n=Math.floor((e+s-1)/s);i=this.chipFamily==g?this.getEraseSize(t,e):e,o=this.IS_STUB?w:ie(ce,e);let c=Date.now();return a=ye("<IIII",i,n,s,t),this.chipFamily==d&&(a=a.concat(ye("<I",r?1:0))),this.logger.log("Erase size "+i+", blocks "+n+", block size "+s+", offset "+f(t,4)+", encrypted "+(r?"yes":"no")),await this.checkCommand(P,a,0,o),0==e||this.IS_STUB||this.logger.log("Took "+(Date.now()-c)+"ms to erase "+n+" bytes"),n}async flashDeflBegin(e=0,t=0,r=0,i=!1){let a,s=this.getFlashWriteSize(),o=Math.floor((t+s-1)/s),n=Math.floor((e+s-1)/s),c=0,l=0;return this.IS_STUB?(c=e,l=w):(c=n*s,l=ie(ce,c)),a=ye("<IIII",c,o,s,r),await this.checkCommand(V,a,0,l),o}async flashFinish(){let e=ye("<I",1);await this.checkCommand(M,e)}async flashDeflFinish(){let e=ye("<I",1);await this.checkCommand(W,e)}getBootloaderOffset(){var e;return this.chipFamily==h||(null===(e=this._parent)||void 0===e?void 0:e.chipFamily)==h?O:j}updateImageFlashParams(e,t){if(t.byteLength<8)return t;var r=Array.from(new Uint8Array(t,0,4));let i=r[0],a=r[2],s=r[3];if(this.logger.debug(`Image header, Magic=${f(i)}, FlashMode=${f(a)}, FlashSizeFreq=${f(s)}`),e!=this.getBootloaderOffset())return t;if(i!=N)return this.logger.log("Warning: Image file at %s doesn't look like an image file, so not changing any flash settings.",f(e,4)),t;this.logger.log("Image being flashed is a bootloader");let o=oe.dio,n=ne["40m"],c=q(this.getChipFamily())[this.flashSize?this.flashSize:"4MB"],l=ye("BB",o,c+n),h=new Uint8Array(t,2,2);return l[0]!=h[0]||l[1]!=h[1]?(h[0]=l[0],h[1]=l[1],this.logger.log(`Patching Flash parameters header bytes to ${f(l[0],2)} ${f(l[1],2)}`)):this.logger.log("Flash parameters header did not need patching."),t}async flashId(){return await this.runSpiFlashCommand(159,[],24)}getChipFamily(){return this._parent?this._parent.chipFamily:this.chipFamily}async writeRegister(e,t,r=4294967295,i=0,a=0){let s=ye("<IIII",e,t,r,i);a>0&&s.concat(ye("<IIII",H(this.getChipFamily()),0,0,a)),await this.checkCommand(Q,s)}async setDataLengths(e,t,r){if(-1!=e.mosiDlenOffs){let i=e.regBase+e.mosiDlenOffs,a=e.regBase+e.misoDlenOffs;t>0&&await this.writeRegister(i,t-1),r>0&&await this.writeRegister(a,r-1)}else{let i=e.regBase+e.usr1Offs,a=(0==r?0:r-1)<<8|(0==t?0:t-1)<<17;await this.writeRegister(i,a)}}async waitDone(e,t){for(let r=0;r<10;r++){if(0==(await this.readRegister(e)&t))return}throw Error("SPI command did not complete in time")}async runSpiFlashCommand(e,t,r=0){let i=G(this.getChipFamily()),a=i.regBase,s=a+0,o=a+i.usrOffs,n=a+i.usr2Offs,c=a+i.w0Offs,l=1<<18;if(r>32)throw new Error("Reading more than 32 bits back from a SPI flash operation is unsupported");if(t.length>64)throw new Error("Writing more than 64 bytes of data with one SPI command is unsupported");let h=8*t.length,d=await this.readRegister(o),g=await this.readRegister(n),p=1<<31;if(r>0&&(p|=268435456),h>0&&(p|=134217728),await this.setDataLengths(i,h,r),await this.writeRegister(o,p),await this.writeRegister(n,7<<28|e),0==h)await this.writeRegister(c,0);else{t.concat(new Array(t.length%4).fill(0));let e=we("I".repeat(Math.floor(t.length/4)),t),r=c;this.logger.debug(`Words Length: ${e.length}`);for(const t of e)this.logger.debug(`Writing word ${f(t)} to register offset ${f(r)}`),await this.writeRegister(r,t),r+=4}await this.writeRegister(s,l),await this.waitDone(s,l);let m=await this.readRegister(c);return await this.writeRegister(o,d),await this.writeRegister(n,g),m}async detectFlashSize(){this.logger.log("Detecting Flash Size");let e=await this.flashId(),t=255&e,r=e>>16&255;this.logger.debug(`FlashId: ${f(e)}`),this.logger.log(`Flash Manufacturer: ${t.toString(16)}`),this.logger.log(`Flash Device: ${(e>>8&255).toString(16)}${r.toString(16)}`),this.flashSize=J[r],this.logger.log(`Auto-detected Flash size: ${this.flashSize}`)}getEraseSize(e,t){let r=ae,i=Math.floor((t+r-1)/r),a=16-Math.floor(e/r)%16;return i<a&&(a=i),i<2*a?Math.floor((i+1)/2*r):(i-a)*r}async memBegin(e,t,r,i){return await this.checkCommand(K,ye("<IIII",e,t,r,i))}async memBlock(e,t){return await this.checkCommand(X,ye("<IIII",e.length,t,0,0).concat(e),this.checksum(e))}async memFinish(e=0){let t=this.IS_STUB?w:Y,r=ye("<II",0==e?1:0,e);return await this.checkCommand(Z,r,0,t)}async runStub(){const e=await ue(this.chipFamily);let t,r=se;this.logger.log("Uploading stub...");for(let t of["text","data"])if(Object.keys(e).includes(t)){let i=e[t+"_start"],a=e[t].length,s=Math.floor((a+r-1)/r);await this.memBegin(a,s,r,i);for(let i of Array(s).keys()){let s=i*r,o=s+r;o>a&&(o=a),await this.memBlock(e[t].slice(s,o),i)}}this.logger.log("Running stub..."),await this.memFinish(e.entry);const i=await this.readPacket(500);if(t=String.fromCharCode(...i),"OHAI"!=t)throw new Error("Failed to start stub. Unexpected response: "+t);this.logger.log("Stub is now running...");const a=new be(this.port,this.logger,this);return await a.detectFlashSize(),a}async writeToStream(e){const t=this.port.writable.getWriter();await t.write(new Uint8Array(e));try{t.releaseLock()}catch(e){console.error("Ignoring release lock error",e)}}async disconnect(){this._parent?await this._parent.disconnect():(await this.port.writable.getWriter().close(),await new Promise((e=>{this._reader||e(void 0),this.addEventListener("disconnect",e,{once:!0}),this._reader.cancel()})),this.connected=!1)}}class be extends _e{constructor(){super(...arguments),this.IS_STUB=!0}async memBegin(e,t,r,i){let a=await ue(this.chipFamily),s=i,o=i+e;console.log(s,o),console.log(a.data_start,a.data.length,a.text_start,a.text.length);for(let[e,t]of[[a.data_start,a.data_start+a.data.length],[a.text_start,a.text_start+a.text.length]])if(s<t&&o>e)throw new Error("Software loader is resident at "+f(e,8)+"-"+f(t,8)+". Can't load binary at overlapping address range "+f(s,8)+"-"+f(o,8)+". Try changing the binary loading address.")}async eraseFlash(){await this.checkCommand(ee,[],0,te)}}const Ie=async e=>{const t=await navigator.serial.requestPort();return e.log("Connecting..."),await t.open({baudRate:B}),e.log("Connected successfully."),new _e(t,e)},ke=async(e,t,r,i)=>{const a=await he(t);if(le[e.chipFamily]!==a.esp_platform.toUpperCase())throw new Error(`Configuration does not match the platform of the connected device. Expected a ${a.esp_platform.toUpperCase()} device.`);let s;try{s=await de(t)}catch(e){throw new Error(`Error fetching manifest.json for ${t}: ${e}`)}const o=s.map((async e=>{const t=new URL(e.path,location.href).toString(),r=await fetch(t);if(!r.ok)throw new Error(`Downlading firmware ${e.path} failed: ${r.status}`);return r.arrayBuffer()})),n=[];let c=0;for(const e of o){const t=await e;n.push(t),c+=t.byteLength}const l=await e.runStub();r&&await l.eraseFlash();let h=0,d=0;i(0);for(const e of s){const t=n.shift();await l.flashData(t,(e=>{const t=Math.floor((d+e)/c*100);t!==h&&(h=t,i(t))}),e.offset,!0),d+=t.byteLength}i(100)};export{Ie as c,ke as f};
