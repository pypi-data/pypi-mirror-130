"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.route53resolver.associate_resolver_query_log_config
hub.exec.boto3.client.route53resolver.create_resolver_query_log_config
hub.exec.boto3.client.route53resolver.delete_resolver_query_log_config
hub.exec.boto3.client.route53resolver.disassociate_resolver_query_log_config
hub.exec.boto3.client.route53resolver.get_resolver_query_log_config
hub.exec.boto3.client.route53resolver.list_resolver_query_log_configs
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, destination_arn: Text, creator_request_id: Text, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a Resolver query logging configuration, which defines where you want Resolver to save DNS query logs
    that originate in your VPCs. Resolver can log queries only for VPCs that are in the same Region as the query
    logging configuration. To specify which VPCs you want to log queries for, you use
    AssociateResolverQueryLogConfig. For more information, see AssociateResolverQueryLogConfig.  You can optionally
    use Resource Access Manager (RAM) to share a query logging configuration with other Amazon Web Services
    accounts. The other accounts can then associate VPCs with the configuration. The query logs that Resolver
    creates for a configuration include all DNS queries that originate in all VPCs that are associated with the
    configuration.

    Args:
        name(Text): The name that you want to give the query logging configuration.
        destination_arn(Text): The ARN of the resource that you want Resolver to send query logs. You can send query logs to an
            S3 bucket, a CloudWatch Logs log group, or a Kinesis Data Firehose delivery stream. Examples of
            valid values include the following:    S3 bucket:   arn:aws:s3:::examplebucket  You can
            optionally append a file prefix to the end of the ARN.  arn:aws:s3:::examplebucket/development/
            CloudWatch Logs log group:   arn:aws:logs:us-west-1:123456789012:log-group:/mystack-
            testgroup-12ABC1AB12A1:*     Kinesis Data Firehose delivery stream:  arn:aws:kinesis:us-
            east-2:0123456789:stream/my_stream_name.
        creator_request_id(Text): A unique string that identifies the request and that allows failed requests to be retried
            without the risk of running the operation twice. CreatorRequestId can be any unique string, for
            example, a date/time stamp.
        tags(List, optional): A list of the tag keys and values that you want to associate with the query logging
            configuration. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.route53resolver.resolver_query_log_config.present:
                - name: value
                - destination_arn: value
                - creator_request_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.route53resolver.resolver_query_log_config.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.route53resolver.get_resolver_query_log_config(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.route53resolver.create_resolver_query_log_config(
                ctx,
                
                
                **{"Name": name, "DestinationArn": destination_arn, "CreatorRequestId": creator_request_id, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.route53resolver.get_resolver_query_log_config(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, resolver_query_log_config_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a query logging configuration. When you delete a configuration, Resolver stops logging DNS queries for
    all of the Amazon VPCs that are associated with the configuration. This also applies if the query logging
    configuration is shared with other Amazon Web Services accounts, and the other accounts have associated VPCs
    with the shared configuration. Before you can delete a query logging configuration, you must first disassociate
    all VPCs from the configuration. See DisassociateResolverQueryLogConfig. If you used Resource Access Manager
    (RAM) to share a query logging configuration with other accounts, you must stop sharing the configuration before
    you can delete a configuration. The accounts that you shared the configuration with can first disassociate VPCs
    that they associated with the configuration, but that's not necessary. If you stop sharing the configuration,
    those VPCs are automatically disassociated from the configuration.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        resolver_query_log_config_id(Text): The ID of the query logging configuration that you want to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.route53resolver.resolver_query_log_config.absent:
                - name: value
                - resolver_query_log_config_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.route53resolver.resolver_query_log_config.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.route53resolver.get_resolver_query_log_config(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.route53resolver.delete_resolver_query_log_config(
                ctx,
                
                
                **{"ResolverQueryLogConfigId": resolver_query_log_config_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.route53resolver.get_resolver_query_log_config(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

