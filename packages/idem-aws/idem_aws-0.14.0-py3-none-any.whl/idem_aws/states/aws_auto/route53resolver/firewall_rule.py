"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.route53resolver.create_firewall_rule
hub.exec.boto3.client.route53resolver.delete_firewall_rule
hub.exec.boto3.client.route53resolver.list_firewall_rules
hub.exec.boto3.client.route53resolver.update_firewall_rule
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, creator_request_id: Text, firewall_rule_group_id: Text, firewall_domain_list_id: Text, priority: int, action: Text, block_response: Text = None, block_override_domain: Text = None, block_override_dns_type: Text = None, block_override_ttl: int = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a single DNS Firewall rule in the specified rule group, using the specified domain list.

    Args:
        name(Text): A name that lets you identify the rule in the rule group.
        creator_request_id(Text): A unique string that identifies the request and that allows you to retry failed requests without
            the risk of running the operation twice. CreatorRequestId can be any unique string, for example,
            a date/time stamp.
        firewall_rule_group_id(Text): The unique identifier of the firewall rule group where you want to create the rule.
        firewall_domain_list_id(Text): The ID of the domain list that you want to use in the rule.
        priority(int): The setting that determines the processing order of the rule in the rule group. DNS Firewall
            processes the rules in a rule group by order of priority, starting from the lowest setting. You
            must specify a unique priority for each rule in a rule group. To make it easier to insert rules
            later, leave space between the numbers, for example, use 100, 200, and so on. You can change the
            priority setting for the rules in a rule group at any time.
        action(Text): The action that DNS Firewall should take on a DNS query when it matches one of the domains in
            the rule's domain list:    ALLOW - Permit the request to go through.    ALERT - Permit the
            request and send metrics and logs to Cloud Watch.    BLOCK - Disallow the request. This option
            requires additional details in the rule's BlockResponse.
        block_response(Text, optional): The way that you want DNS Firewall to block the request, used with the rule action setting
            BLOCK.     NODATA - Respond indicating that the query was successful, but no response is
            available for it.    NXDOMAIN - Respond indicating that the domain name that's in the query
            doesn't exist.    OVERRIDE - Provide a custom override in the response. This option requires
            custom handling details in the rule's BlockOverride* settings.    This setting is required if
            the rule action setting is BLOCK. Defaults to None.
        block_override_domain(Text, optional): The custom DNS record to send back in response to the query. Used for the rule action BLOCK with
            a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is
            OVERRIDE. Defaults to None.
        block_override_dns_type(Text, optional): The DNS record's type. This determines the format of the record value that you provided in
            BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
            This setting is required if the BlockResponse setting is OVERRIDE. Defaults to None.
        block_override_ttl(int, optional): The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the
            provided override record. Used for the rule action BLOCK with a BlockResponse setting of
            OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.route53resolver.firewall_rule.present:
                - name: value
                - creator_request_id: value
                - firewall_rule_group_id: value
                - firewall_domain_list_id: value
                - priority: value
                - action: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.route53resolver.firewall_rule.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.route53resolver.list_firewall_rules(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.route53resolver.create_firewall_rule(
                ctx,
                
                
                **{"Name": name, "CreatorRequestId": creator_request_id, "FirewallRuleGroupId": firewall_rule_group_id, "FirewallDomainListId": firewall_domain_list_id, "Priority": priority, "Action": action, "BlockResponse": block_response, "BlockOverrideDomain": block_override_domain, "BlockOverrideDnsType": block_override_dns_type, "BlockOverrideTtl": block_override_ttl}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.route53resolver.list_firewall_rules(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, firewall_rule_group_id: Text, firewall_domain_list_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified firewall rule.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        firewall_rule_group_id(Text): The unique identifier of the firewall rule group that you want to delete the rule from.
        firewall_domain_list_id(Text): The ID of the domain list that's used in the rule.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.route53resolver.firewall_rule.absent:
                - name: value
                - firewall_rule_group_id: value
                - firewall_domain_list_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.route53resolver.firewall_rule.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.route53resolver.list_firewall_rules(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.route53resolver.delete_firewall_rule(
                ctx,
                
                
                **{"FirewallRuleGroupId": firewall_rule_group_id, "FirewallDomainListId": firewall_domain_list_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.route53resolver.list_firewall_rules(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

