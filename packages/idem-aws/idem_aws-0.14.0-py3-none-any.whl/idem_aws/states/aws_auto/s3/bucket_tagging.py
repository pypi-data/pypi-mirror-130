"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.s3.delete_bucket_tagging
hub.exec.boto3.client.s3.get_bucket_tagging
hub.exec.boto3.client.s3.put_bucket_tagging
resource = hub.tool.boto3.resource.create(ctx, "s3", "BucketTagging", name)
hub.tool.boto3.resource.exec(resource, delete, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, put, *args, **kwargs)
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, bucket: Text, tagging: Dict, content_md5: Text = None, expected_bucket_owner: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Sets the tags for a bucket. Use tags to organize your Amazon Web Services bill to reflect your own cost
    structure. To do this, sign up to get your Amazon Web Services account bill with tag key values included. Then,
    to see the cost of combined resources, organize your billing information according to resources with the same
    tag key values. For example, you can tag several resources with a specific application name, and then organize
    your billing information to see the total cost of that application across several services. For more
    information, see Cost Allocation and Tagging and Using Cost Allocation in Amazon S3 Bucket Tags.   When this
    operation sets the tags for a bucket, it will overwrite any current tags the bucket already has. You cannot use
    this operation to add tags to an existing list of tags.  To use this operation, you must have permissions to
    perform the s3:PutBucketTagging action. The bucket owner has this permission by default and can grant this
    permission to others. For more information about permissions, see Permissions Related to Bucket Subresource
    Operations and Managing Access Permissions to Your Amazon S3 Resources.  PutBucketTagging has the following
    special errors:   Error code: InvalidTagError    Description: The tag provided was not a valid tag. This error
    can occur if the tag did not pass input validation. For information about tag restrictions, see User-Defined Tag
    Restrictions and Amazon Web Services-Generated Cost Allocation Tag Restrictions.     Error code:
    MalformedXMLError    Description: The XML provided does not match the schema.     Error code:
    OperationAbortedError     Description: A conflicting conditional action is currently in progress against this
    resource. Please try again.     Error code: InternalError    Description: The service was unable to apply the
    provided tag to the bucket.     The following operations are related to PutBucketTagging:    GetBucketTagging
    DeleteBucketTagging

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        bucket(Text): The bucket name.
        content_md5(Text, optional): The base64-encoded 128-bit MD5 digest of the data. You must use this header as a message
            integrity check to verify that the request body was not corrupted in transit. For more
            information, see RFC 1864. For requests made using the Amazon Web Services Command Line
            Interface (CLI) or Amazon Web Services SDKs, this field is calculated automatically. Defaults to None.
        tagging(Dict): Container for the TagSet and Tag elements.
        expected_bucket_owner(Text, optional): The account ID of the expected bucket owner. If the bucket is owned by a different account, the
            request will fail with an HTTP 403 (Access Denied) error. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.s3.bucket_tagging.present:
                - name: value
                - bucket: value
                - tagging: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.s3.bucket_tagging.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "s3", "BucketTagging", name)
    before = await hub.tool.boto3.resource.describe(resource)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.s3.put_bucket_tagging(
                ctx,
                
                
                **{"Bucket": bucket, "ContentMD5": content_md5, "Tagging": tagging, "ExpectedBucketOwner": expected_bucket_owner}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, bucket: Text, expected_bucket_owner: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the tags from the bucket. To use this operation, you must have permission to perform the
    s3:PutBucketTagging action. By default, the bucket owner has this permission and can grant this permission to
    others.  The following operations are related to DeleteBucketTagging:    GetBucketTagging     PutBucketTagging

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        bucket(Text): The bucket that has the tag set to be removed.
        expected_bucket_owner(Text, optional): The account ID of the expected bucket owner. If the bucket is owned by a different account, the
            request will fail with an HTTP 403 (Access Denied) error. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.s3.bucket_tagging.absent:
                - name: value
                - bucket: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.s3.bucket_tagging.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "s3", "BucketTagging", name)

    before = await hub.tool.boto3.resource.describe(resource)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.s3.delete_bucket_tagging(
                ctx,
                
                
                **{"Bucket": bucket, "ExpectedBucketOwner": expected_bucket_owner}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result

