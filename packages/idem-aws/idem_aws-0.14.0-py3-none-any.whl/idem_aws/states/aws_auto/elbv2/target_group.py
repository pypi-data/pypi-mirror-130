"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.elbv2.create_target_group
hub.exec.boto3.client.elbv2.delete_target_group
hub.exec.boto3.client.elbv2.describe_target_groups
hub.exec.boto3.client.elbv2.modify_target_group
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, protocol: Text = None, protocol_version: Text = None, port: int = None, vpc_id: Text = None, health_check_protocol: Text = None, health_check_port: Text = None, health_check_enabled: bool = None, health_check_path: Text = None, health_check_interval_seconds: int = None, health_check_timeout_seconds: int = None, healthy_threshold_count: int = None, unhealthy_threshold_count: int = None, matcher: Dict = None, target_type: Text = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a target group. For more information, see the following:    Target groups for your Application Load
    Balancers     Target groups for your Network Load Balancers     Target groups for your Gateway Load Balancers
    This operation is idempotent, which means that it completes at most one time. If you attempt to create multiple
    target groups with the same settings, each call succeeds.

    Args:
        name(Text): The name of the target group. This name must be unique per region per account, can have a
            maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not
            begin or end with a hyphen.
        protocol(Text, optional): The protocol to use for routing traffic to the targets. For Application Load Balancers, the
            supported protocols are HTTP and HTTPS. For Network Load Balancers, the supported protocols are
            TCP, TLS, UDP, or TCP_UDP. For Gateway Load Balancers, the supported protocol is GENEVE. A
            TCP_UDP listener must be associated with a TCP_UDP target group. If the target is a Lambda
            function, this parameter does not apply. Defaults to None.
        protocol_version(Text, optional): [HTTP/HTTPS protocol] The protocol version. Specify GRPC to send requests to targets using gRPC.
            Specify HTTP2 to send requests to targets using HTTP/2. The default is HTTP1, which sends
            requests to targets using HTTP/1.1. Defaults to None.
        port(int, optional): The port on which the targets receive traffic. This port is used unless you specify a port
            override when registering the target. If the target is a Lambda function, this parameter does
            not apply. If the protocol is GENEVE, the supported port is 6081. Defaults to None.
        vpc_id(Text, optional): The identifier of the virtual private cloud (VPC). If the target is a Lambda function, this
            parameter does not apply. Otherwise, this parameter is required. Defaults to None.
        health_check_protocol(Text, optional): The protocol the load balancer uses when performing health checks on targets. For Application
            Load Balancers, the default is HTTP. For Network Load Balancers and Gateway Load Balancers, the
            default is TCP. The TCP protocol is not supported for health checks if the protocol of the
            target group is HTTP or HTTPS. The GENEVE, TLS, UDP, and TCP_UDP protocols are not supported for
            health checks. Defaults to None.
        health_check_port(Text, optional): The port the load balancer uses when performing health checks on targets. If the protocol is
            HTTP, HTTPS, TCP, TLS, UDP, or TCP_UDP, the default is traffic-port, which is the port on which
            each target receives traffic from the load balancer. If the protocol is GENEVE, the default is
            port 80. Defaults to None.
        health_check_enabled(bool, optional): Indicates whether health checks are enabled. If the target type is lambda, health checks are
            disabled by default but can be enabled. If the target type is instance or ip, health checks are
            always enabled and cannot be disabled. Defaults to None.
        health_check_path(Text, optional): [HTTP/HTTPS health checks] The destination for health checks on the targets. [HTTP1 or HTTP2
            protocol version] The ping path. The default is /. [GRPC protocol version] The path of a custom
            health check method with the format /package.service/method. The default is /Amazon Web
            Services.ALB/healthcheck. Defaults to None.
        health_check_interval_seconds(int, optional): The approximate amount of time, in seconds, between health checks of an individual target. If
            the target group protocol is TCP, TLS, UDP, or TCP_UDP, the supported values are 10 and 30
            seconds. If the target group protocol is HTTP or HTTPS, the default is 30 seconds. If the target
            group protocol is GENEVE, the default is 10 seconds. If the target type is lambda, the default
            is 35 seconds. Defaults to None.
        health_check_timeout_seconds(int, optional): The amount of time, in seconds, during which no response from a target means a failed health
            check. For target groups with a protocol of HTTP, HTTPS, or GENEVE, the default is 5 seconds.
            For target groups with a protocol of TCP or TLS, this value must be 6 seconds for HTTP health
            checks and 10 seconds for TCP and HTTPS health checks. If the target type is lambda, the default
            is 30 seconds. Defaults to None.
        healthy_threshold_count(int, optional): The number of consecutive health checks successes required before considering an unhealthy
            target healthy. For target groups with a protocol of HTTP or HTTPS, the default is 5. For target
            groups with a protocol of TCP, TLS, or GENEVE, the default is 3. If the target type is lambda,
            the default is 5. Defaults to None.
        unhealthy_threshold_count(int, optional): The number of consecutive health check failures required before considering a target unhealthy.
            If the target group protocol is HTTP or HTTPS, the default is 2. If the target group protocol is
            TCP or TLS, this value must be the same as the healthy threshold count. If the target group
            protocol is GENEVE, the default is 3. If the target type is lambda, the default is 2. Defaults to None.
        matcher(Dict, optional): [HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful response
            from a target. Defaults to None.
        target_type(Text, optional): The type of target that you must specify when registering targets with this target group. You
            can't specify targets for a target group using more than one target type.    instance - Register
            targets by instance ID. This is the default value.    ip - Register targets by IP address. You
            can specify IP addresses from the subnets of the virtual private cloud (VPC) for the target
            group, the RFC 1918 range (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), and the RFC 6598
            range (100.64.0.0/10). You can't specify publicly routable IP addresses.    lambda - Register a
            single Lambda function as a target. Defaults to None.
        tags(List, optional): The tags to assign to the target group. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.elbv2.target_group.present:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)

    
    before = await hub.exec.boto3.client.elbv2.describe_target_groups(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.elbv2.create_target_group(
                ctx,
                
                
                **{"Name": name, "Protocol": protocol, "ProtocolVersion": protocol_version, "Port": port, "VpcId": vpc_id, "HealthCheckProtocol": health_check_protocol, "HealthCheckPort": health_check_port, "HealthCheckEnabled": health_check_enabled, "HealthCheckPath": health_check_path, "HealthCheckIntervalSeconds": health_check_interval_seconds, "HealthCheckTimeoutSeconds": health_check_timeout_seconds, "HealthyThresholdCount": healthy_threshold_count, "UnhealthyThresholdCount": unhealthy_threshold_count, "Matcher": matcher, "TargetType": target_type, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.elbv2.describe_target_groups(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, target_group_arn: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified target group. You can delete a target group if it is not referenced by any actions.
    Deleting a target group also deletes any associated health checks. Deleting a target group does not affect its
    registered targets. For example, any EC2 instances continue to run until you stop or terminate them.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        target_group_arn(Text): The Amazon Resource Name (ARN) of the target group.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.elbv2.target_group.absent:
                - name: value
                - target_group_arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.elbv2.target_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.elbv2.describe_target_groups(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.elbv2.delete_target_group(
                ctx,
                
                
                **{"TargetGroupArn": target_group_arn}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.elbv2.describe_target_groups(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

