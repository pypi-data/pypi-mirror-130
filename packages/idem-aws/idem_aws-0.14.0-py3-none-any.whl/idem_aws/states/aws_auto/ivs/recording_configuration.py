"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.ivs.create_recording_configuration
hub.exec.boto3.client.ivs.delete_recording_configuration
hub.exec.boto3.client.ivs.get_recording_configuration
hub.exec.boto3.client.ivs.list_recording_configurations
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, destination_configuration: Dict, name: Text = None, tags: Dict = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a new recording configuration, used to enable recording to Amazon S3.  Known issue: In the us-east-1
    region, if you use the AWS CLI to create a recording configuration, it returns success even if the S3 bucket is
    in a different region. In this case, the state of the recording configuration is CREATE_FAILED (instead of
    ACTIVE). (In other regions, the CLI correctly returns failure if the bucket is in a different region.)
    Workaround: Ensure that your S3 bucket is in the same region as the recording configuration. If you create a
    recording configuration in a different region as your S3 bucket, delete that recording configuration and create
    a new one with an S3 bucket from the correct region.

    Args:
        name(Text, optional): An arbitrary string (a nickname) that helps the customer identify that resource. The value does
            not need to be unique. Defaults to None.
        destination_configuration(Dict): A complex type that contains a destination configuration for where recorded video will be
            stored.
        tags(Dict, optional): Array of 1-50 maps, each of the form string:string (key:value). Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.ivs.recording_configuration.present:
                - destination_configuration: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.ivs.recording_configuration.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.ivs.get_recording_configuration(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.ivs.create_recording_configuration(
                ctx,
                
                
                **{"Name": name, "destinationConfiguration": destination_configuration, "tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.ivs.get_recording_configuration(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, arn: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the recording configuration for the specified ARN. If you try to delete a recording configuration that
    is associated with a channel, you will get an error (409 ConflictException). To avoid this, for all channels
    that reference the recording configuration, first use UpdateChannel to set the recordingConfigurationArn field
    to an empty string, then use DeleteRecordingConfiguration.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        arn(Text): ARN of the recording configuration to be deleted.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.ivs.recording_configuration.absent:
                - name: value
                - arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.ivs.recording_configuration.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.ivs.get_recording_configuration(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.ivs.delete_recording_configuration(
                ctx,
                
                
                **{"arn": arn}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.ivs.get_recording_configuration(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

