"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.appflow.create_flow
hub.exec.boto3.client.appflow.delete_flow
hub.exec.boto3.client.appflow.describe_flow
hub.exec.boto3.client.appflow.list_flows
hub.exec.boto3.client.appflow.start_flow
hub.exec.boto3.client.appflow.stop_flow
hub.exec.boto3.client.appflow.update_flow
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, flow_name: Text, trigger_config: Dict, source_flow_config: Dict, destination_flow_config_list: List, tasks: List, description: Text = None, kms_arn: Text = None, tags: Dict = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
     Enables your application to create a new flow using Amazon AppFlow. You must create a connector profile before
    calling this API. Please note that the Request Syntax below shows syntax for multiple destinations, however, you
    can only transfer data to one item in this list at a time. Amazon AppFlow does not currently support flows to
    multiple destinations at once.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        flow_name(Text):  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-)
            only.
        description(Text, optional):  A description of the flow you want to create. Defaults to None.
        kms_arn(Text, optional):  The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for
            encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If
            you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key. Defaults to None.
        trigger_config(Dict):  The trigger settings that determine how and when the flow runs.
        source_flow_config(Dict):  The configuration that controls how Amazon AppFlow retrieves data from the source connector.
        destination_flow_config_list(List):  The configuration that controls how Amazon AppFlow places data in the destination connector.
        tasks(List):  A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
        tags(Dict, optional):  The tags used to organize, track, or control access for your flow. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.appflow.flow.present:
                - name: value
                - flow_name: value
                - trigger_config: value
                - source_flow_config: value
                - destination_flow_config_list: value
                - tasks: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.appflow.flow.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.appflow.describe_flow(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.appflow.create_flow(
                ctx,
                
                
                **{"flowName": flow_name, "description": description, "kmsArn": kms_arn, "triggerConfig": trigger_config, "sourceFlowConfig": source_flow_config, "destinationFlowConfigList": destination_flow_config_list, "tasks": tasks, "tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.appflow.describe_flow(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, flow_name: Text, force_delete: bool = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
     Enables your application to delete an existing flow. Before deleting the flow, Amazon AppFlow validates the
    request by checking the flow configuration and status. You can delete flows one at a time.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        flow_name(Text):  The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-)
            only.
        force_delete(bool, optional):  Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.appflow.flow.absent:
                - name: value
                - flow_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.appflow.flow.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.appflow.describe_flow(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.appflow.delete_flow(
                ctx,
                
                
                **{"flowName": flow_name, "forceDelete": force_delete}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.appflow.describe_flow(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

