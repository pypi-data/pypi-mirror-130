"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.dynamodb.create_backup
hub.exec.boto3.client.dynamodb.delete_backup
hub.exec.boto3.client.dynamodb.describe_backup
hub.exec.boto3.client.dynamodb.list_backups
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, table_name: Text, backup_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a backup for an existing table.  Each time you create an on-demand backup, the entire table data is
    backed up. There is no limit to the number of on-demand backups that can be taken.   When you create an on-
    demand backup, a time marker of the request is cataloged, and the backup is created asynchronously, by applying
    all changes until the time of the request to the last full table snapshot. Backup requests are processed
    instantaneously and become available for restore within minutes.  You can call CreateBackup at a maximum rate of
    50 times per second. All backups in DynamoDB work without consuming any provisioned throughput on the table.  If
    you submit a backup request on 2018-12-14 at 14:25:00, the backup is guaranteed to contain all data committed to
    the table up to 14:24:00, and data committed after 14:26:00 will not be. The backup might contain data
    modifications made between 14:24:00 and 14:26:00. On-demand backup does not support causal consistency.   Along
    with data, the following are also included on the backups:    Global secondary indexes (GSIs)   Local secondary
    indexes (LSIs)   Streams   Provisioned read and write capacity

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        table_name(Text): The name of the table.
        backup_name(Text): Specified name for the backup.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.dynamodb.backup.present:
                - name: value
                - table_name: value
                - backup_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.dynamodb.backup.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.dynamodb.describe_backup(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.dynamodb.create_backup(
                ctx,
                
                
                **{"TableName": table_name, "BackupName": backup_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.dynamodb.describe_backup(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, backup_arn: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes an existing backup of a table. You can call DeleteBackup at a maximum rate of 10 times per second.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        backup_arn(Text): The ARN associated with the backup.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.dynamodb.backup.absent:
                - name: value
                - backup_arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.dynamodb.backup.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.dynamodb.describe_backup(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.dynamodb.delete_backup(
                ctx,
                
                
                **{"BackupArn": backup_arn}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.dynamodb.describe_backup(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

