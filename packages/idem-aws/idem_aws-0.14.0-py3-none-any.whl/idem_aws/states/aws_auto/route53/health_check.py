"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.route53.create_health_check
hub.exec.boto3.client.route53.delete_health_check
hub.exec.boto3.client.route53.get_health_check
hub.exec.boto3.client.route53.list_health_checks
hub.exec.boto3.client.route53.update_health_check
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, caller_reference: Text, health_check_config: Dict)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a new health check. For information about adding health checks to resource record sets, see
    HealthCheckId in ChangeResourceRecordSets.   ELB Load Balancers  If you're registering EC2 instances with an
    Elastic Load Balancing (ELB) load balancer, do not create Amazon Route 53 health checks for the EC2 instances.
    When you register an EC2 instance with a load balancer, you configure settings for an ELB health check, which
    performs a similar function to a Route 53 health check.  Private Hosted Zones  You can associate health checks
    with failover resource record sets in a private hosted zone. Note the following:   Route 53 health checkers are
    outside the VPC. To check the health of an endpoint within a VPC by IP address, you must assign a public IP
    address to the instance in the VPC.   You can configure a health checker to check the health of an external
    resource that the instance relies on, such as a database server.   You can create a CloudWatch metric, associate
    an alarm with the metric, and then create a health check that is based on the state of the alarm. For example,
    you might create a CloudWatch metric that checks the status of the Amazon EC2 StatusCheckFailed metric, add an
    alarm to the metric, and then create a health check that is based on the state of the alarm. For information
    about creating CloudWatch metrics and alarms by using the CloudWatch console, see the Amazon CloudWatch User
    Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        caller_reference(Text): A unique string that identifies the request and that allows you to retry a failed
            CreateHealthCheck request without the risk of creating two identical health checks:   If you
            send a CreateHealthCheck request with the same CallerReference and settings as a previous
            request, and if the health check doesn't exist, Amazon Route 53 creates the health check. If the
            health check does exist, Route 53 returns the settings for the existing health check.   If you
            send a CreateHealthCheck request with the same CallerReference as a deleted health check,
            regardless of the settings, Route 53 returns a HealthCheckAlreadyExists error.   If you send a
            CreateHealthCheck request with the same CallerReference as an existing health check but with
            different settings, Route 53 returns a HealthCheckAlreadyExists error.   If you send a
            CreateHealthCheck request with a unique CallerReference but settings identical to an existing
            health check, Route 53 creates the health check.
        health_check_config(Dict): A complex type that contains settings for a new health check.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.route53.health_check.present:
                - name: value
                - caller_reference: value
                - health_check_config: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.route53.health_check.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.route53.get_health_check(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.route53.create_health_check(
                ctx,
                
                
                **{"CallerReference": caller_reference, "HealthCheckConfig": health_check_config}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.route53.get_health_check(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, health_check_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a health check.  Amazon Route 53 does not prevent you from deleting a health check even if the health
    check is associated with one or more resource record sets. If you delete a health check and you don't update the
    associated resource record sets, the future status of the health check can't be predicted and may change. This
    will affect the routing of DNS queries for your DNS failover configuration. For more information, see Replacing
    and Deleting Health Checks in the Amazon Route 53 Developer Guide.  If you're using Cloud Map and you configured
    Cloud Map to create a Route 53 health check when you register an instance, you can't use the Route 53
    DeleteHealthCheck command to delete the health check. The health check is deleted automatically when you
    deregister the instance; there can be a delay of several hours before the health check is deleted from Route 53.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        health_check_id(Text): The ID of the health check that you want to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.route53.health_check.absent:
                - name: value
                - health_check_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.route53.health_check.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.route53.get_health_check(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.route53.delete_health_check(
                ctx,
                
                
                **{"HealthCheckId": health_check_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.route53.get_health_check(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

