"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.network_firewall.create_firewall
hub.exec.boto3.client.network_firewall.delete_firewall
hub.exec.boto3.client.network_firewall.describe_firewall
hub.exec.boto3.client.network_firewall.list_firewalls
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, firewall_name: Text, firewall_policy_arn: Text, vpc_id: Text, subnet_mappings: List, delete_protection: bool = None, subnet_change_protection: bool = None, firewall_policy_change_protection: bool = None, description: Text = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates an AWS Network Firewall Firewall and accompanying FirewallStatus for a VPC.  The firewall defines the
    configuration settings for an AWS Network Firewall firewall. The settings that you can define at creation
    include the firewall policy, the subnets in your VPC to use for the firewall endpoints, and any tags that are
    attached to the firewall AWS resource.  After you create a firewall, you can provide additional settings, like
    the logging configuration.  To update the settings for a firewall, you use the operations that apply to the
    settings themselves, for example UpdateLoggingConfiguration, AssociateSubnets, and
    UpdateFirewallDeleteProtection.  To manage a firewall's tags, use the standard AWS resource tagging operations,
    ListTagsForResource, TagResource, and UntagResource. To retrieve information about firewalls, use ListFirewalls
    and DescribeFirewall.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        firewall_name(Text): The descriptive name of the firewall. You can't change the name of a firewall after you create
            it.
        firewall_policy_arn(Text): The Amazon Resource Name (ARN) of the FirewallPolicy that you want to use for the firewall.
        vpc_id(Text): The unique identifier of the VPC where Network Firewall should create the firewall.  You can't
            change this setting after you create the firewall.
        subnet_mappings(List): The public subnets to use for your Network Firewall firewalls. Each subnet must belong to a
            different Availability Zone in the VPC. Network Firewall creates a firewall endpoint in each
            subnet.
        delete_protection(bool, optional): A flag indicating whether it is possible to delete the firewall. A setting of TRUE indicates
            that the firewall is protected against deletion. Use this setting to protect against
            accidentally deleting a firewall that is in use. When you create a firewall, the operation
            initializes this flag to TRUE. Defaults to None.
        subnet_change_protection(bool, optional): A setting indicating whether the firewall is protected against changes to the subnet
            associations. Use this setting to protect against accidentally modifying the subnet associations
            for a firewall that is in use. When you create a firewall, the operation initializes this
            setting to TRUE. Defaults to None.
        firewall_policy_change_protection(bool, optional): A setting indicating whether the firewall is protected against a change to the firewall policy
            association. Use this setting to protect against accidentally modifying the firewall policy for
            a firewall that is in use. When you create a firewall, the operation initializes this setting to
            TRUE. Defaults to None.
        description(Text, optional): A description of the firewall. Defaults to None.
        tags(List, optional): The key:value pairs to associate with the resource. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.network_firewall.firewall.present:
                - name: value
                - firewall_name: value
                - firewall_policy_arn: value
                - vpc_id: value
                - subnet_mappings: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.network_firewall.firewall.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.network_firewall.describe_firewall(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.network_firewall.create_firewall(
                ctx,
                
                
                **{"FirewallName": firewall_name, "FirewallPolicyArn": firewall_policy_arn, "VpcId": vpc_id, "SubnetMappings": subnet_mappings, "DeleteProtection": delete_protection, "SubnetChangeProtection": subnet_change_protection, "FirewallPolicyChangeProtection": firewall_policy_change_protection, "Description": description, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.network_firewall.describe_firewall(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, firewall_name: Text = None, firewall_arn: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified Firewall and its FirewallStatus. This operation requires the firewall's DeleteProtection
    flag to be FALSE. You can't revert this operation.  You can check whether a firewall is in use by reviewing the
    route tables for the Availability Zones where you have firewall subnet mappings. Retrieve the subnet mappings by
    calling DescribeFirewall. You define and update the route tables through Amazon VPC. As needed, update the route
    tables for the zones to remove the firewall endpoints. When the route tables no longer use the firewall
    endpoints, you can remove the firewall safely. To delete a firewall, remove the delete protection if you need to
    using UpdateFirewallDeleteProtection, then delete the firewall by calling DeleteFirewall.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        firewall_name(Text, optional): The descriptive name of the firewall. You can't change the name of a firewall after you create
            it. You must specify the ARN or the name, and you can specify both. Defaults to None.
        firewall_arn(Text, optional): The Amazon Resource Name (ARN) of the firewall. You must specify the ARN or the name, and you
            can specify both. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.network_firewall.firewall.absent:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.network_firewall.firewall.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.network_firewall.describe_firewall(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.network_firewall.delete_firewall(
                ctx,
                
                
                **{"FirewallName": firewall_name, "FirewallArn": firewall_arn}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.network_firewall.describe_firewall(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

