"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.network_firewall.create_rule_group
hub.exec.boto3.client.network_firewall.delete_rule_group
hub.exec.boto3.client.network_firewall.describe_rule_group
hub.exec.boto3.client.network_firewall.list_rule_groups
hub.exec.boto3.client.network_firewall.update_rule_group
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, rule_group_name: Text, type_: Text, capacity: int, rule_group: Dict = None, rules: Text = None, description: Text = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates the specified stateless or stateful rule group, which includes the rules for network traffic inspection,
    a capacity setting, and tags.  You provide your rule group specification in your request using either RuleGroup
    or Rules.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        rule_group_name(Text): The descriptive name of the rule group. You can't change the name of a rule group after you
            create it.
        rule_group(Dict, optional): An object that defines the rule group rules.   You must provide either this rule group setting
            or a Rules setting, but not both. Defaults to None.
        rules(Text, optional): A string containing stateful rule group rules specifications in Suricata flat format, with one
            rule per line. Use this to import your existing Suricata compatible rule groups.   You must
            provide either this rules setting or a populated RuleGroup setting, but not both.   You can
            provide your rule group specification in Suricata flat format through this setting when you
            create or update your rule group. The call response returns a RuleGroup object that Network
            Firewall has populated from your string. Defaults to None.
        type_(Text): Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it
            contains stateless rules. If it is stateful, it contains stateful rules.
        description(Text, optional): A description of the rule group. Defaults to None.
        capacity(int): The maximum operating resources that this rule group can use. Rule group capacity is fixed at
            creation. When you update a rule group, you are limited to this capacity. When you reference a
            rule group from a firewall policy, Network Firewall reserves this capacity for the rule group.
            You can retrieve the capacity that would be required for a rule group before you create the rule
            group by calling CreateRuleGroup with DryRun set to TRUE.   You can't change or exceed this
            capacity when you update the rule group, so leave room for your rule group to grow.    Capacity
            for a stateless rule group  For a stateless rule group, the capacity required is the sum of the
            capacity requirements of the individual rules that you expect to have in the rule group.  To
            calculate the capacity requirement of a single rule, multiply the capacity requirement values of
            each of the rule's match settings:   A match setting with no criteria specified has a value of
            1.    A match setting with Any specified has a value of 1.    All other match settings have a
            value equal to the number of elements provided in the setting. For example, a protocol setting
            ["UDP"] and a source setting ["10.0.0.0/24"] each have a value of 1. A protocol setting
            ["UDP","TCP"] has a value of 2. A source setting ["10.0.0.0/24","10.0.0.1/24","10.0.0.2/24"] has
            a value of 3.    A rule with no criteria specified in any of its match settings has a capacity
            requirement of 1. A rule with protocol setting ["UDP","TCP"], source setting
            ["10.0.0.0/24","10.0.0.1/24","10.0.0.2/24"], and a single specification or no specification for
            each of the other match settings has a capacity requirement of 6.   Capacity for a stateful rule
            group  For a stateful rule group, the minimum capacity required is the number of individual
            rules that you expect to have in the rule group.
        tags(List, optional): The key:value pairs to associate with the resource. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.network_firewall.rule_group.present:
                - name: value
                - rule_group_name: value
                - type_: value
                - capacity: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.network_firewall.rule_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.network_firewall.describe_rule_group(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.network_firewall.create_rule_group(
                ctx,
                DryRun=ctx.test,
                
                **{"RuleGroupName": rule_group_name, "RuleGroup": rule_group, "Rules": rules, "Type": type_, "Description": description, "Capacity": capacity, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.network_firewall.describe_rule_group(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, rule_group_name: Text = None, rule_group_arn: Text = None, type_: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified RuleGroup.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        rule_group_name(Text, optional): The descriptive name of the rule group. You can't change the name of a rule group after you
            create it. You must specify the ARN or the name, and you can specify both. Defaults to None.
        rule_group_arn(Text, optional): The Amazon Resource Name (ARN) of the rule group. You must specify the ARN or the name, and you
            can specify both. Defaults to None.
        type_(Text, optional): Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it
            contains stateless rules. If it is stateful, it contains stateful rules.   This setting is
            required for requests that do not include the RuleGroupARN. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.network_firewall.rule_group.absent:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.network_firewall.rule_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.network_firewall.describe_rule_group(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.network_firewall.delete_rule_group(
                ctx,
                
                
                **{"RuleGroupName": rule_group_name, "RuleGroupArn": rule_group_arn, "Type": type_}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.network_firewall.describe_rule_group(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

