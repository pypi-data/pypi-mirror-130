"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.eks.create_cluster
hub.exec.boto3.client.eks.delete_cluster
hub.exec.boto3.client.eks.describe_cluster
hub.exec.boto3.client.eks.list_clusters
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, role_arn: Text, resources_vpc_config: Dict, version: Text = None, kubernetes_network_config: Dict = None, logging: Dict = None, client_request_token: Text = None, tags: Dict = None, encryption_config: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates an Amazon EKS control plane.  The Amazon EKS control plane consists of control plane instances that run
    the Kubernetes software, such as etcd and the API server. The control plane runs in an account managed by Amazon
    Web Services, and the Kubernetes API is exposed via the Amazon EKS API server endpoint. Each Amazon EKS cluster
    control plane is single-tenant and unique and runs on its own set of Amazon EC2 instances. The cluster control
    plane is provisioned across multiple Availability Zones and fronted by an Elastic Load Balancing Network Load
    Balancer. Amazon EKS also provisions elastic network interfaces in your VPC subnets to provide connectivity from
    the control plane instances to the nodes (for example, to support kubectl exec, logs, and proxy data flows).
    Amazon EKS nodes run in your Amazon Web Services account and connect to your cluster's control plane via the
    Kubernetes API server endpoint and a certificate file that is created for your cluster. Cluster creation
    typically takes several minutes. After you create an Amazon EKS cluster, you must configure your Kubernetes
    tooling to communicate with the API server and launch nodes into your cluster. For more information, see
    Managing Cluster Authentication and Launching Amazon EKS nodes in the Amazon EKS User Guide.

    Args:
        name(Text): The unique name to give to your cluster.
        version(Text, optional): The desired Kubernetes version for your cluster. If you don't specify a value here, the latest
            version available in Amazon EKS is used. Defaults to None.
        role_arn(Text): The Amazon Resource Name (ARN) of the IAM role that provides permissions for the Kubernetes
            control plane to make calls to Amazon Web Services API operations on your behalf. For more
            information, see Amazon EKS Service IAM Role in the  Amazon EKS User Guide .
        resources_vpc_config(Dict): The VPC configuration used by the cluster control plane. Amazon EKS VPC resources have specific
            requirements to work properly with Kubernetes. For more information, see Cluster VPC
            Considerations and Cluster Security Group Considerations in the Amazon EKS User Guide. You must
            specify at least two subnets. You can specify up to five security groups, but we recommend that
            you use a dedicated security group for your cluster control plane.
        kubernetes_network_config(Dict, optional): The Kubernetes network configuration for the cluster. Defaults to None.
        logging(Dict, optional): Enable or disable exporting the Kubernetes control plane logs for your cluster to CloudWatch
            Logs. By default, cluster control plane logs aren't exported to CloudWatch Logs. For more
            information, see Amazon EKS Cluster control plane logs in the  Amazon EKS User Guide .
            CloudWatch Logs ingestion, archive storage, and data scanning rates apply to exported control
            plane logs. For more information, see CloudWatch Pricing. Defaults to None.
        client_request_token(Text, optional): Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Defaults to None.
        tags(Dict, optional): The metadata to apply to the cluster to assist with categorization and organization. Each tag
            consists of a key and an optional value, both of which you define. Defaults to None.
        encryption_config(List, optional): The encryption configuration for the cluster. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.eks.cluster.present:
                - name: value
                - role_arn: value
                - resources_vpc_config: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.eks.cluster.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.eks.describe_cluster(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.eks.create_cluster(
                ctx,
                
                
                **{"Name": name, "version": version, "roleArn": role_arn, "resourcesVpcConfig": resources_vpc_config, "kubernetesNetworkConfig": kubernetes_network_config, "logging": logging, "clientRequestToken": client_request_token, "tags": tags, "encryptionConfig": encryption_config}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.eks.describe_cluster(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the Amazon EKS cluster control plane. If you have active services in your cluster that are associated
    with a load balancer, you must delete those services before deleting the cluster so that the load balancers are
    deleted properly. Otherwise, you can have orphaned resources in your VPC that prevent you from being able to
    delete the VPC. For more information, see Deleting a Cluster in the Amazon EKS User Guide. If you have managed
    node groups or Fargate profiles attached to the cluster, you must delete them first. For more information, see
    DeleteNodegroup and DeleteFargateProfile.

    Args:
        name(Text): The name of the cluster to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.eks.cluster.absent:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.eks.cluster.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.eks.describe_cluster(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.eks.delete_cluster(
                ctx,
                
                
                **{"Name": name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.eks.describe_cluster(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

