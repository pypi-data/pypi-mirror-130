"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.fms.delete_policy
hub.exec.boto3.client.fms.get_policy
hub.exec.boto3.client.fms.list_policies
hub.exec.boto3.client.fms.put_policy
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, policy: Dict, tag_list: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates an Firewall Manager policy. Firewall Manager provides the following types of policies:    An WAF policy
    (type WAFV2), which defines rule groups to run first in the corresponding WAF web ACL and rule groups to run
    last in the web ACL.   An WAF Classic policy (type WAF), which defines a rule group.    A Shield Advanced
    policy, which applies Shield Advanced protection to specified accounts and resources.   A security group policy,
    which manages VPC security groups across your Amazon Web Services organization.    An Network Firewall policy,
    which provides firewall rules to filter network traffic in specified Amazon VPCs.   A DNS Firewall policy, which
    provides Route 53 Resolver DNS Firewall rules to filter DNS queries for specified VPCs.   Each policy is
    specific to one of the types. If you want to enforce more than one policy type across accounts, create multiple
    policies. You can create multiple policies for each type. You must be subscribed to Shield Advanced to create a
    Shield Advanced policy. For more information about subscribing to Shield Advanced, see CreateSubscription.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        policy(Dict): The details of the Firewall Manager policy to be created.
        tag_list(List, optional): The tags to add to the Amazon Web Services resource. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.fms.policy.present:
                - name: value
                - policy: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.fms.policy.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.fms.get_policy(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.fms.put_policy(
                ctx,
                
                
                **{"Policy": policy, "TagList": tag_list}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.fms.get_policy(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, policy_id: Text, delete_all_policy_resources: bool = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Permanently deletes an Firewall Manager policy.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        policy_id(Text): The ID of the policy that you want to delete. You can retrieve this ID from PutPolicy and
            ListPolicies.
        delete_all_policy_resources(bool, optional): If True, the request performs cleanup according to the policy type.  For WAF and Shield Advanced
            policies, the cleanup does the following:   Deletes rule groups created by Firewall Manager
            Removes web ACLs from in-scope resources   Deletes web ACLs that contain no rules or rule groups
            For security group policies, the cleanup does the following for each security group in the
            policy:   Disassociates the security group from in-scope resources    Deletes the security group
            if it was created through Firewall Manager and if it's no longer associated with any resources
            through another policy   After the cleanup, in-scope resources are no longer protected by web
            ACLs in this policy. Protection of out-of-scope resources remains unchanged. Scope is determined
            by tags that you create and accounts that you associate with the policy. When creating the
            policy, if you specify that only resources in specific accounts or with specific tags are in
            scope of the policy, those accounts and resources are handled by the policy. All others are out
            of scope. If you don't specify tags or accounts, all resources are in scope. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.fms.policy.absent:
                - name: value
                - policy_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.fms.policy.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.fms.get_policy(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.fms.delete_policy(
                ctx,
                
                
                **{"PolicyId": policy_id, "DeleteAllPolicyResources": delete_all_policy_resources}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.fms.get_policy(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

