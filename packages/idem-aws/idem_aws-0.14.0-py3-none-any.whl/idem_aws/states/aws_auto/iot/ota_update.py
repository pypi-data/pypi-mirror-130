"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.iot.create_ota_update
hub.exec.boto3.client.iot.delete_ota_update
hub.exec.boto3.client.iot.get_ota_update
hub.exec.boto3.client.iot.list_ota_updates
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, ota_update_id: Text, targets: List, files: List, role_arn: Text, description: Text = None, protocols: List = None, target_selection: Text = None, aws_job_executions_rollout_config: Dict = None, aws_job_presigned_url_config: Dict = None, aws_job_abort_config: Dict = None, aws_job_timeout_config: Dict = None, additional_parameters: Dict = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates an AWS IoT OTAUpdate on a target group of things or groups.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        ota_update_id(Text): The ID of the OTA update to be created.
        description(Text, optional): The description of the OTA update. Defaults to None.
        targets(List): The devices targeted to receive OTA updates.
        protocols(List, optional): The protocol used to transfer the OTA update image. Valid values are [HTTP], [MQTT], [HTTP,
            MQTT]. When both HTTP and MQTT are specified, the target device can choose the protocol. Defaults to None.
        target_selection(Text, optional): Specifies whether the update will continue to run (CONTINUOUS), or will be complete after all
            the things specified as targets have completed the update (SNAPSHOT). If continuous, the update
            may also be run on a thing when a change is detected in a target. For example, an update will
            run on a thing when the thing is added to a target group, even after the update was completed by
            all things originally in the group. Valid values: CONTINUOUS | SNAPSHOT. Defaults to None.
        aws_job_executions_rollout_config(Dict, optional): Configuration for the rollout of OTA updates. Defaults to None.
        aws_job_presigned_url_config(Dict, optional): Configuration information for pre-signed URLs. Defaults to None.
        aws_job_abort_config(Dict, optional): The criteria that determine when and how a job abort takes place. Defaults to None.
        aws_job_timeout_config(Dict, optional): Specifies the amount of time each device has to finish its execution of the job. A timer is
            started when the job execution status is set to IN_PROGRESS. If the job execution status is not
            set to another terminal state before the timer expires, it will be automatically set to
            TIMED_OUT. Defaults to None.
        files(List): The files to be streamed by the OTA update.
        role_arn(Text): The IAM role that grants AWS IoT access to the Amazon S3, AWS IoT jobs and AWS Code Signing
            resources to create an OTA update job.
        additional_parameters(Dict, optional): A list of additional OTA update parameters which are name-value pairs. Defaults to None.
        tags(List, optional): Metadata which can be used to manage updates. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.iot.ota_update.present:
                - name: value
                - ota_update_id: value
                - targets: value
                - files: value
                - role_arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.iot.ota_update.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.iot.get_ota_update(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.iot.create_ota_update(
                ctx,
                
                
                **{"otaUpdateId": ota_update_id, "description": description, "targets": targets, "protocols": protocols, "targetSelection": target_selection, "awsJobExecutionsRolloutConfig": aws_job_executions_rollout_config, "awsJobPresignedUrlConfig": aws_job_presigned_url_config, "awsJobAbortConfig": aws_job_abort_config, "awsJobTimeoutConfig": aws_job_timeout_config, "files": files, "roleArn": role_arn, "additionalParameters": additional_parameters, "tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.iot.get_ota_update(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, ota_update_id: Text, delete_stream: bool = None, force_delete_aws_job: bool = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Delete an OTA update.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        ota_update_id(Text): The ID of the OTA update to delete.
        delete_stream(bool, optional): When true, the stream created by the OTAUpdate process is deleted when the OTA update is
            deleted. Ignored if the stream specified in the OTAUpdate is supplied by the user. Defaults to None.
        force_delete_aws_job(bool, optional): When true, deletes the AWS job created by the OTAUpdate process even if it is "IN_PROGRESS".
            Otherwise, if the job is not in a terminal state ("COMPLETED" or "CANCELED") an exception will
            occur. The default is false. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.iot.ota_update.absent:
                - name: value
                - ota_update_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.iot.ota_update.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.iot.get_ota_update(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.iot.delete_ota_update(
                ctx,
                
                
                **{"otaUpdateId": ota_update_id, "deleteStream": delete_stream, "forceDeleteAWSJob": force_delete_aws_job}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.iot.get_ota_update(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

