"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.servicediscovery.create_service
hub.exec.boto3.client.servicediscovery.delete_service
hub.exec.boto3.client.servicediscovery.get_service
hub.exec.boto3.client.servicediscovery.list_services
hub.exec.boto3.client.servicediscovery.update_service
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, namespace_id: Text = None, creator_request_id: Text = None, description: Text = None, dns_config: Dict = None, health_check_config: Dict = None, health_check_custom_config: Dict = None, tags: List = None, type_: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a service. This action defines the configuration for the following entities:   For public and private
    DNS namespaces, one of the following combinations of DNS records in Amazon Route 53:    A     AAAA     A and
    AAAA     SRV     CNAME      Optionally, a health check   After you create the service, you can submit a
    RegisterInstance request, and Cloud Map uses the values in the configuration to create the specified entities.
    For the current quota on the number of instances that you can register using the same namespace and using the
    same service, see Cloud Map quotas in the Cloud Map Developer Guide.

    Args:
        name(Text): The name that you want to assign to the service. If you want Cloud Map to create an SRV record
            when you register an instance and you're using a system that requires a specific SRV format,
            such as HAProxy, specify the following for Name:   Start the name with an underscore (_), such
            as _exampleservice.   End the name with ._protocol, such as ._tcp.   When you register an
            instance, Cloud Map creates an SRV record and assigns a name to the record by concatenating the
            service name and the namespace name (for example,  _exampleservice._tcp.example.com).  For
            services that are accessible by DNS queries, you can't create multiple services with names that
            differ only by case (such as EXAMPLE and example). Otherwise, these services have the same DNS
            name and can't be distinguished. However, if you use a namespace that's only accessible by API
            calls, then you can create services that with names that differ only by case.
        namespace_id(Text, optional): The ID of the namespace that you want to use to create the service. The namespace ID must be
            specified, but it can be specified either here or in the DnsConfig object. Defaults to None.
        creator_request_id(Text, optional): A unique string that identifies the request and that allows failed CreateService requests to be
            retried without the risk of running the operation twice. CreatorRequestId can be any unique
            string (for example, a date/timestamp). Defaults to None.
        description(Text, optional): A description for the service. Defaults to None.
        dns_config(Dict, optional): A complex type that contains information about the Amazon Route 53 records that you want Cloud
            Map to create when you register an instance. Defaults to None.
        health_check_config(Dict, optional):  Public DNS and HTTP namespaces only. A complex type that contains settings for an optional
            Route 53 health check. If you specify settings for a health check, Cloud Map associates the
            health check with all the Route 53 DNS records that you specify in DnsConfig.  If you specify a
            health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig
            but not both.  For information about the charges for health checks, see Cloud Map Pricing. Defaults to None.
        health_check_custom_config(Dict, optional): A complex type that contains information about an optional custom health check.  If you specify
            a health check configuration, you can specify either HealthCheckCustomConfig or
            HealthCheckConfig but not both.  You can't add, update, or delete a HealthCheckCustomConfig
            configuration from an existing service. Defaults to None.
        tags(List, optional): The tags to add to the service. Each tag consists of a key and an optional value that you
            define. Tags keys can be up to 128 characters in length, and tag values can be up to 256
            characters in length. Defaults to None.
        type_(Text, optional): If present, specifies that the service instances are only discoverable using the
            DiscoverInstances API operation. No DNS records is registered for the service instances. The
            only valid value is HTTP. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.servicediscovery.service.present:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.servicediscovery.service.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.servicediscovery.get_service(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.servicediscovery.create_service(
                ctx,
                
                
                **{"Name": name, "NamespaceId": namespace_id, "CreatorRequestId": creator_request_id, "Description": description, "DnsConfig": dns_config, "HealthCheckConfig": health_check_config, "HealthCheckCustomConfig": health_check_custom_config, "Tags": tags, "Type": type_}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.servicediscovery.get_service(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, id_: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a specified service. If the service still contains one or more registered instances, the request fails.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        id_(Text): The ID of the service that you want to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.servicediscovery.service.absent:
                - name: value
                - id_: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.servicediscovery.service.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.servicediscovery.get_service(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.servicediscovery.delete_service(
                ctx,
                
                
                **{"Id": id_}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.servicediscovery.get_service(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

