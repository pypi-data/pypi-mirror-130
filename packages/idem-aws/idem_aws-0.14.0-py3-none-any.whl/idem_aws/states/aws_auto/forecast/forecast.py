"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.forecast.create_forecast
hub.exec.boto3.client.forecast.delete_forecast
hub.exec.boto3.client.forecast.describe_forecast
hub.exec.boto3.client.forecast.list_forecasts
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, forecast_name: Text, predictor_arn: Text, forecast_types: List = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a forecast for each item in the TARGET_TIME_SERIES dataset that was used to train the predictor. This is
    known as inference. To retrieve the forecast for a single item at low latency, use the operation. To export the
    complete forecast into your Amazon Simple Storage Service (Amazon S3) bucket, use the CreateForecastExportJob
    operation. The range of the forecast is determined by the ForecastHorizon value, which you specify in the
    CreatePredictor request. When you query a forecast, you can request a specific date range within the forecast.
    To get a list of all your forecasts, use the ListForecasts operation.  The forecasts generated by Amazon
    Forecast are in the same time zone as the dataset that was used to create the predictor.  For more information,
    see howitworks-forecast.  The Status of the forecast must be ACTIVE before you can query or export the forecast.
    Use the DescribeForecast operation to get the status.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        forecast_name(Text): A name for the forecast.
        predictor_arn(Text): The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.
        forecast_types(List, optional): The quantiles at which probabilistic forecasts are generated. You can currently specify up to 5
            quantiles per forecast. Accepted values include 0.01 to 0.99 (increments of .01 only) and mean.
            The mean forecast is different from the median (0.50) when the distribution is not symmetric
            (for example, Beta and Negative Binomial). The default value is ["0.1", "0.5", "0.9"]. Defaults to None.
        tags(List, optional): The optional metadata that you apply to the forecast to help you categorize and organize them.
            Each tag consists of a key and an optional value, both of which you define. The following basic
            restrictions apply to tags:   Maximum number of tags per resource - 50.   For each resource,
            each tag key must be unique, and each tag key can have only one value.   Maximum key length -
            128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in UTF-8.   If
            your tagging schema is used across multiple services and resources, remember that other services
            may have restrictions on allowed characters. Generally allowed characters are: letters, numbers,
            and spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and
            values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of
            such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with
            this prefix. Values can have this prefix. If a tag value has aws as its prefix but the key does
            not, then Forecast considers it to be a user tag and will count against the limit of 50 tags.
            Tags with only the key prefix of aws do not count against your tags per resource limit. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.forecast.forecast.present:
                - name: value
                - forecast_name: value
                - predictor_arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.forecast.forecast.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.forecast.describe_forecast(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.forecast.create_forecast(
                ctx,
                
                
                **{"ForecastName": forecast_name, "PredictorArn": predictor_arn, "ForecastTypes": forecast_types, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.forecast.describe_forecast(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, forecast_arn: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a forecast created using the CreateForecast operation. You can delete only forecasts that have a status
    of ACTIVE or CREATE_FAILED. To get the status, use the DescribeForecast operation. You can't delete a forecast
    while it is being exported. After a forecast is deleted, you can no longer query the forecast.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        forecast_arn(Text): The Amazon Resource Name (ARN) of the forecast to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.forecast.forecast.absent:
                - name: value
                - forecast_arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.forecast.forecast.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.forecast.describe_forecast(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.forecast.delete_forecast(
                ctx,
                
                
                **{"ForecastArn": forecast_arn}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.forecast.describe_forecast(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

