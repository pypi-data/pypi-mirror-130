"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.forecast.create_dataset_group
hub.exec.boto3.client.forecast.delete_dataset_group
hub.exec.boto3.client.forecast.describe_dataset_group
hub.exec.boto3.client.forecast.list_dataset_groups
hub.exec.boto3.client.forecast.update_dataset_group
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, dataset_group_name: Text, domain: Text, dataset_arns: List = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a dataset group, which holds a collection of related datasets. You can add datasets to the dataset group
    when you create the dataset group, or later by using the UpdateDatasetGroup operation. After creating a dataset
    group and adding datasets, you use the dataset group when you create a predictor. For more information, see
    howitworks-datasets-groups. To get a list of all your datasets groups, use the ListDatasetGroups operation.  The
    Status of a dataset group must be ACTIVE before you can use the dataset group to create a predictor. To get the
    status, use the DescribeDatasetGroup operation.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        dataset_group_name(Text): A name for the dataset group.
        domain(Text): The domain associated with the dataset group. When you add a dataset to a dataset group, this
            value and the value specified for the Domain parameter of the CreateDataset operation must
            match. The Domain and DatasetType that you choose determine the fields that must be present in
            training data that you import to a dataset. For example, if you choose the RETAIL domain and
            TARGET_TIME_SERIES as the DatasetType, Amazon Forecast requires that item_id, timestamp, and
            demand fields are present in your data. For more information, see howitworks-datasets-groups.
        dataset_arns(List, optional): An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the dataset
            group. Defaults to None.
        tags(List, optional): The optional metadata that you apply to the dataset group to help you categorize and organize
            them. Each tag consists of a key and an optional value, both of which you define. The following
            basic restrictions apply to tags:   Maximum number of tags per resource - 50.   For each
            resource, each tag key must be unique, and each tag key can have only one value.   Maximum key
            length - 128 Unicode characters in UTF-8.   Maximum value length - 256 Unicode characters in
            UTF-8.   If your tagging schema is used across multiple services and resources, remember that
            other services may have restrictions on allowed characters. Generally allowed characters are:
            letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : /
            @.   Tag keys and values are case sensitive.   Do not use aws:, AWS:, or any upper or lowercase
            combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or
            delete tag keys with this prefix. Values can have this prefix. If a tag value has aws as its
            prefix but the key does not, then Forecast considers it to be a user tag and will count against
            the limit of 50 tags. Tags with only the key prefix of aws do not count against your tags per
            resource limit. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.forecast.dataset_group.present:
                - name: value
                - dataset_group_name: value
                - domain: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.forecast.dataset_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.forecast.describe_dataset_group(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.forecast.create_dataset_group(
                ctx,
                
                
                **{"DatasetGroupName": dataset_group_name, "Domain": domain, "DatasetArns": dataset_arns, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.forecast.describe_dataset_group(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, dataset_group_arn: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a dataset group created using the CreateDatasetGroup operation. You can only delete dataset groups that
    have a status of ACTIVE, CREATE_FAILED, or UPDATE_FAILED. To get the status, use the DescribeDatasetGroup
    operation. This operation deletes only the dataset group, not the datasets in the group.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        dataset_group_arn(Text): The Amazon Resource Name (ARN) of the dataset group to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.forecast.dataset_group.absent:
                - name: value
                - dataset_group_arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.forecast.dataset_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.forecast.describe_dataset_group(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.forecast.delete_dataset_group(
                ctx,
                
                
                **{"DatasetGroupArn": dataset_group_arn}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.forecast.describe_dataset_group(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

