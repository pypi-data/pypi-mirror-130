"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.timestream_write.create_table
hub.exec.boto3.client.timestream_write.delete_table
hub.exec.boto3.client.timestream_write.describe_table
hub.exec.boto3.client.timestream_write.list_tables
hub.exec.boto3.client.timestream_write.update_table
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, database_name: Text, table_name: Text, retention_properties: Dict = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    The CreateTable operation adds a new table to an existing database in your account. In an AWS account, table
    names must be at least unique within each Region if they are in the same database. You may have identical table
    names in the same Region if the tables are in seperate databases. While creating the table, you must specify the
    table name, database name, and the retention properties. Service quotas apply. For more information, see Access
    Management in the Timestream Developer Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        database_name(Text): The name of the Timestream database.
        table_name(Text): The name of the Timestream table.
        retention_properties(Dict, optional): The duration for which your time series data must be stored in the memory store and the magnetic
            store. Defaults to None.
        tags(List, optional):  A list of key-value pairs to label the table. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.timestream_write.table.present:
                - name: value
                - database_name: value
                - table_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.timestream_write.table.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.timestream_write.describe_table(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.timestream_write.create_table(
                ctx,
                
                
                **{"DatabaseName": database_name, "TableName": table_name, "RetentionProperties": retention_properties, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.timestream_write.describe_table(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, database_name: Text, table_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a given Timestream table. This is an irreversible operation. After a Timestream database table is
    deleted, the time series data stored in the table cannot be recovered.  Due to the nature of distributed
    retries, the operation can return either success or a ResourceNotFoundException. Clients should consider them
    equivalent.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        database_name(Text): The name of the database where the Timestream database is to be deleted.
        table_name(Text): The name of the Timestream table to be deleted.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.timestream_write.table.absent:
                - name: value
                - database_name: value
                - table_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.timestream_write.table.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.timestream_write.describe_table(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.timestream_write.delete_table(
                ctx,
                
                
                **{"DatabaseName": database_name, "TableName": table_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.timestream_write.describe_table(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

