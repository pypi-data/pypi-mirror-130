"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.ec2.create_placement_group
hub.exec.boto3.client.ec2.delete_placement_group
hub.exec.boto3.client.ec2.describe_placement_groups
resource = hub.tool.boto3.resource.create(ctx, "ec2", "PlacementGroup", name)
hub.tool.boto3.resource.exec(resource, delete, *args, **kwargs)
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, group_name: Text = None, strategy: Text = None, partition_count: int = None, tag_specifications: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a placement group in which to launch instances. The strategy of the placement group determines how the
    instances are organized within the group.  A cluster placement group is a logical grouping of instances within a
    single Availability Zone that benefit from low network latency, high network throughput. A spread placement
    group places instances on distinct hardware. A partition placement group places groups of instances in different
    partitions, where instances in one partition do not share the same hardware with instances in another partition.
    For more information, see Placement groups in the Amazon EC2 User Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        group_name(Text, optional): A name for the placement group. Must be unique within the scope of your account for the Region.
            Constraints: Up to 255 ASCII characters. Defaults to None.
        strategy(Text, optional): The placement strategy. Defaults to None.
        partition_count(int, optional): The number of partitions. Valid only when Strategy is set to partition. Defaults to None.
        tag_specifications(List, optional): The tags to apply to the new placement group. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.ec2.placement_group.present:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.ec2.placement_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "ec2", "PlacementGroup", name)
    before = await hub.tool.boto3.resource.describe(resource)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.ec2.create_placement_group(
                ctx,
                DryRun=ctx.test,
                
                **{"GroupName": group_name, "Strategy": strategy, "PartitionCount": partition_count, "TagSpecifications": tag_specifications}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, group_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified placement group. You must terminate all instances in the placement group before you can
    delete the placement group. For more information, see Placement groups in the Amazon EC2 User Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        group_name(Text): The name of the placement group.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.ec2.placement_group.absent:
                - name: value
                - group_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.ec2.placement_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "ec2", "PlacementGroup", name)

    before = await hub.tool.boto3.resource.describe(resource)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.ec2.delete_placement_group(
                ctx,
                DryRun=ctx.test,
                
                **{"GroupName": group_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result

