"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.ec2.associate_route_table
hub.exec.boto3.client.ec2.create_route_table
hub.exec.boto3.client.ec2.delete_route_table
hub.exec.boto3.client.ec2.describe_route_tables
hub.exec.boto3.client.ec2.disassociate_route_table
resource = hub.tool.boto3.resource.create(ctx, "ec2", "RouteTable", name)
hub.tool.boto3.resource.exec(resource, associate_with_subnet, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, create_route, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, create_tags, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, delete, *args, **kwargs)
"""



import copy
from typing import *
import dict_tools.differ as differ

async def present(hub, ctx, name: Text, vpc_id: Text, tag_specifications: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a route table for the specified VPC. After you create a route table, you can add routes and associate
    the table with a subnet. For more information, see Route tables in the Amazon Virtual Private Cloud User Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        vpc_id(Text): The ID of the VPC.
        tag_specifications(List, optional): The tags to assign to the route table. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.ec2.route_table.present:
                - name: value
                - vpc_id: value
    '''

    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.ec2.route_table.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "ec2", "RouteTable", name)
    before = await hub.tool.boto3.resource.describe(resource)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.ec2.create_route_table(
                ctx,
                DryRun=ctx.test,
                
                **{"VpcId": vpc_id, "TagSpecifications": tag_specifications}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result



async def absent(hub, ctx, name: Text, route_table_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified route table. You must disassociate the route table from any subnets before you can delete
    it. You can't delete the main route table.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        route_table_id(Text): The ID of the route table.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.ec2.route_table.absent:
                - name: value
                - route_table_id: value
    '''

    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.ec2.route_table.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "ec2", "RouteTable", name)

    before = await hub.tool.boto3.resource.describe(resource)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.ec2.delete_route_table(
                ctx,
                DryRun=ctx.test,
                
                **{"RouteTableId": route_table_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result



async def describe(hub, ctx)  -> Dict[str, Dict[str, Any]]:
    r'''
    **Autogenerated function**

    Describe the resource in a way that can be recreated/managed with the corresponding "present" function

    
    Describes one or more of your route tables. Each subnet in your VPC must be associated with a route table. If a
    subnet is not explicitly associated with any route table, it is implicitly associated with the main route table.
    This command does not return the subnet ID for implicit associations. For more information, see Route tables in
    the Amazon Virtual Private Cloud User Guide.


    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: bash

            $ idem describe aws_auto.ec2.route_table
    '''

    
    result = {}

    ret = await hub.exec.boto3.client.ec2.describe_route_tables(ctx)
    if not ret["status"]:
        hub.log.debug(f"Could not describe route_table {ret['comment']}")
        return result

    for route_table in ret["ret"]["TODO"]:
        new_route_table = [
                {"Filters": filters, "RouteTableIds": route_table_ids, "NextToken": next_token, "MaxResults": max_results}
        ]
        result[route_table["route_tableId"]] = {"aws_auto.ec2.route_table.present": new_route_table}

        for i, data in enumerate(route_table.get("", ())):
            sub_route_table = copy.deepcopy(new_route_table)

            # TODO check for subresouruces
            sub_route_table.append({})
            sub_route_table.append({"name": "TODOs"})
            result[f"TODOs-{i}"] = {"aws_auto.ec2.route_table.present": sub_route_table}

    return result


