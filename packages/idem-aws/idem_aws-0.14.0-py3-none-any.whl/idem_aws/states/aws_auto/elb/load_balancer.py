"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.elb.create_load_balancer
hub.exec.boto3.client.elb.delete_load_balancer
hub.exec.boto3.client.elb.describe_load_balancers
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, load_balancer_name: Text, listeners: List, availability_zones: List = None, subnets: List = None, security_groups: List = None, scheme: Text = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a Classic Load Balancer. You can add listeners, security groups, subnets, and tags when you create your
    load balancer, or you can add them later using CreateLoadBalancerListeners, ApplySecurityGroupsToLoadBalancer,
    AttachLoadBalancerToSubnets, and AddTags. To describe your current load balancers, see DescribeLoadBalancers.
    When you are finished with a load balancer, you can delete it using DeleteLoadBalancer. You can create up to 20
    load balancers per region per account. You can request an increase for the number of load balancers for your
    account. For more information, see Limits for Your Classic Load Balancer in the Classic Load Balancers Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        load_balancer_name(Text): The name of the load balancer. This name must be unique within your set of load balancers for
            the region, must have a maximum of 32 characters, must contain only alphanumeric characters or
            hyphens, and cannot begin or end with a hyphen.
        listeners(List): The listeners. For more information, see Listeners for Your Classic Load Balancer in the Classic
            Load Balancers Guide.
        availability_zones(List, optional): One or more Availability Zones from the same region as the load balancer. You must specify at
            least one Availability Zone. You can add more Availability Zones after you create the load
            balancer using EnableAvailabilityZonesForLoadBalancer. Defaults to None.
        subnets(List, optional): The IDs of the subnets in your VPC to attach to the load balancer. Specify one subnet per
            Availability Zone specified in AvailabilityZones. Defaults to None.
        security_groups(List, optional): The IDs of the security groups to assign to the load balancer. Defaults to None.
        scheme(Text, optional): The type of a load balancer. Valid only for load balancers in a VPC. By default, Elastic Load
            Balancing creates an Internet-facing load balancer with a DNS name that resolves to public IP
            addresses. For more information about Internet-facing and Internal load balancers, see Load
            Balancer Scheme in the Elastic Load Balancing User Guide. Specify internal to create a load
            balancer with a DNS name that resolves to private IP addresses. Defaults to None.
        tags(List, optional): A list of tags to assign to the load balancer. For more information about tagging your load
            balancer, see Tag Your Classic Load Balancer in the Classic Load Balancers Guide. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.elb.load_balancer.present:
                - name: value
                - load_balancer_name: value
                - listeners: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.elb.load_balancer.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.elb.describe_load_balancers(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.elb.create_load_balancer(
                ctx,
                
                
                **{"LoadBalancerName": load_balancer_name, "Listeners": listeners, "AvailabilityZones": availability_zones, "Subnets": subnets, "SecurityGroups": security_groups, "Scheme": scheme, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.elb.describe_load_balancers(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, load_balancer_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified load balancer. If you are attempting to recreate a load balancer, you must reconfigure all
    settings. The DNS name associated with a deleted load balancer are no longer usable. The name and associated DNS
    record of the deleted load balancer no longer exist and traffic sent to any of its IP addresses is no longer
    delivered to your instances. If the load balancer does not exist or has already been deleted, the call to
    DeleteLoadBalancer still succeeds.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        load_balancer_name(Text): The name of the load balancer.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.elb.load_balancer.absent:
                - name: value
                - load_balancer_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.elb.load_balancer.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.elb.describe_load_balancers(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.elb.delete_load_balancer(
                ctx,
                
                
                **{"LoadBalancerName": load_balancer_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.elb.describe_load_balancers(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

