"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.appmesh.create_mesh
hub.exec.boto3.client.appmesh.delete_mesh
hub.exec.boto3.client.appmesh.describe_mesh
hub.exec.boto3.client.appmesh.list_meshes
hub.exec.boto3.client.appmesh.update_mesh
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, mesh_name: Text, client_token: Text = None, spec: Dict = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a service mesh.  A service mesh is a logical boundary for network traffic between services that are
    represented by resources within the mesh. After you create your service mesh, you can create virtual services,
    virtual nodes, virtual routers, and routes to distribute traffic between the applications in your mesh. For more
    information about service meshes, see Service meshes.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        client_token(Text, optional): Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Up
            to 36 letters, numbers, hyphens, and underscores are allowed. Defaults to None.
        mesh_name(Text): The name to use for the service mesh.
        spec(Dict, optional): The service mesh specification to apply. Defaults to None.
        tags(List, optional): Optional metadata that you can apply to the service mesh to assist with categorization and
            organization. Each tag consists of a key and an optional value, both of which you define. Tag
            keys can have a maximum character length of 128 characters, and tag values can have a maximum
            length of 256 characters. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.appmesh.mesh.present:
                - name: value
                - mesh_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.appmesh.mesh.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.appmesh.describe_mesh(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.appmesh.create_mesh(
                ctx,
                
                
                **{"clientToken": client_token, "meshName": mesh_name, "spec": spec, "tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.appmesh.describe_mesh(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, mesh_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes an existing service mesh. You must delete all resources (virtual services, routes, virtual routers, and
    virtual nodes) in the service mesh before you can delete the mesh itself.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        mesh_name(Text): The name of the service mesh to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.appmesh.mesh.absent:
                - name: value
                - mesh_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.appmesh.mesh.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.appmesh.describe_mesh(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.appmesh.delete_mesh(
                ctx,
                
                
                **{"meshName": mesh_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.appmesh.describe_mesh(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

