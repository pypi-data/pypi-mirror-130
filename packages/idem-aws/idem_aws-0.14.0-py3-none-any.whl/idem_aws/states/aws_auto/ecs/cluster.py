"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.ecs.create_cluster
hub.exec.boto3.client.ecs.delete_cluster
hub.exec.boto3.client.ecs.describe_clusters
hub.exec.boto3.client.ecs.list_clusters
hub.exec.boto3.client.ecs.update_cluster
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, cluster_name: Text = None, tags: List = None, settings: List = None, configuration: Dict = None, capacity_providers: List = None, default_capacity_provider_strategy: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a new Amazon ECS cluster. By default, your account receives a default cluster when you launch your first
    container instance. However, you can create your own cluster with a unique name with the CreateCluster action.
    When you call the CreateCluster API operation, Amazon ECS attempts to create the Amazon ECS service-linked role
    for your account so that required resources in other Amazon Web Services services can be managed on your behalf.
    However, if the IAM user that makes the call does not have permissions to create the service-linked role, it is
    not created. For more information, see Using Service-Linked Roles for Amazon ECS in the Amazon Elastic Container
    Service Developer Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        cluster_name(Text, optional): The name of your cluster. If you do not specify a name for your cluster, you create a cluster
            named default. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens
            are allowed. Defaults to None.
        tags(List, optional): The metadata that you apply to the cluster to help you categorize and organize them. Each tag
            consists of a key and an optional value, both of which you define. The following basic
            restrictions apply to tags:   Maximum number of tags per resource - 50   For each resource, each
            tag key must be unique, and each tag key can have only one value.   Maximum key length - 128
            Unicode characters in UTF-8   Maximum value length - 256 Unicode characters in UTF-8   If your
            tagging schema is used across multiple services and resources, remember that other services may
            have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and
            spaces representable in UTF-8, and the following characters: + - = . _ : / @.   Tag keys and
            values are case-sensitive.   Do not use aws:, AWS:, or any upper or lowercase combination of
            such as a prefix for either keys or values as it is reserved for Amazon Web Services use. You
            cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count
            against your tags per resource limit. Defaults to None.
        settings(List, optional): The setting to use when creating a cluster. This parameter is used to enable CloudWatch
            Container Insights for a cluster. If this value is specified, it will override the
            containerInsights value set with PutAccountSetting or PutAccountSettingDefault. Defaults to None.
        configuration(Dict, optional): The execute command configuration for the cluster. Defaults to None.
        capacity_providers(List, optional): The short name of one or more capacity providers to associate with the cluster. A capacity
            provider must be associated with a cluster before it can be included as part of the default
            capacity provider strategy of the cluster or used in a capacity provider strategy when calling
            the CreateService or RunTask actions. If specifying a capacity provider that uses an Auto
            Scaling group, the capacity provider must already be created and not already associated with
            another cluster. New Auto Scaling group capacity providers can be created with the
            CreateCapacityProvider API operation. To use a Fargate capacity provider, specify either the
            FARGATE or FARGATE_SPOT capacity providers. The Fargate capacity providers are available to all
            accounts and only need to be associated with a cluster to be used. The
            PutClusterCapacityProviders API operation is used to update the list of available capacity
            providers for a cluster after the cluster is created. Defaults to None.
        default_capacity_provider_strategy(List, optional): The capacity provider strategy to set as the default for the cluster. When a default capacity
            provider strategy is set for a cluster, when calling the RunTask or CreateService APIs with no
            capacity provider strategy or launch type specified, the default capacity provider strategy for
            the cluster is used. If a default capacity provider strategy is not defined for a cluster during
            creation, it can be defined later with the PutClusterCapacityProviders API operation. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.ecs.cluster.present:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.ecs.cluster.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.ecs.describe_clusters(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.ecs.create_cluster(
                ctx,
                
                
                **{"clusterName": cluster_name, "tags": tags, "settings": settings, "configuration": configuration, "capacityProviders": capacity_providers, "defaultCapacityProviderStrategy": default_capacity_provider_strategy}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.ecs.describe_clusters(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, cluster: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified cluster. The cluster will transition to the INACTIVE state. Clusters with an INACTIVE
    status may remain discoverable in your account for a period of time. However, this behavior is subject to change
    in the future, so you should not rely on INACTIVE clusters persisting. You must deregister all container
    instances from this cluster before you may delete it. You can list the container instances in a cluster with
    ListContainerInstances and deregister them with DeregisterContainerInstance.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        cluster(Text): The short name or full Amazon Resource Name (ARN) of the cluster to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.ecs.cluster.absent:
                - name: value
                - cluster: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.ecs.cluster.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.ecs.describe_clusters(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.ecs.delete_cluster(
                ctx,
                
                
                **{"cluster": cluster}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.ecs.describe_clusters(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

