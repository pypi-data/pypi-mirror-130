"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.lambda_.delete_layer_version
hub.exec.boto3.client.lambda_.get_layer_version
hub.exec.boto3.client.lambda_.list_layer_versions
hub.exec.boto3.client.lambda_.publish_layer_version
"""



import copy
from typing import *
import dict_tools.differ as differ

async def present(hub, ctx, name: Text, layer_name: Text, content: Dict, description: Text = None, compatible_runtimes: List = None, license_info: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates an Lambda layer from a ZIP archive. Each time you call PublishLayerVersion with the same layer name, a
    new version is created. Add layers to your function with CreateFunction or UpdateFunctionConfiguration.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        layer_name(Text): The name or Amazon Resource Name (ARN) of the layer.
        description(Text, optional): The description of the version. Defaults to None.
        content(Dict): The function layer archive.
        compatible_runtimes(List, optional): A list of compatible function runtimes. Used for filtering with ListLayers and
            ListLayerVersions. Defaults to None.
        license_info(Text, optional): The layer's software license. It can be any of the following:   An SPDX license identifier. For
            example, MIT.   The URL of a license hosted on the internet. For example,
            https://opensource.org/licenses/MIT.   The full text of the license. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.lambda_.layer_version.present:
                - name: value
                - layer_name: value
                - content: value
    '''

    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.lambda_.layer_version.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.lambda_.get_layer_version(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.lambda_.publish_layer_version(
                ctx,
                
                
                **{"LayerName": layer_name, "Description": description, "Content": content, "CompatibleRuntimes": compatible_runtimes, "LicenseInfo": license_info}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.lambda_.get_layer_version(name)
    result["changes"] = differ.deep_diff(before, after)
    return result



async def absent(hub, ctx, name: Text, layer_name: Text, version_number: int)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a version of an Lambda layer. Deleted versions can no longer be viewed or added to functions. To avoid
    breaking functions, a copy of the version remains in Lambda until no functions refer to it.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        layer_name(Text): The name or Amazon Resource Name (ARN) of the layer.
        version_number(int): The version number.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.lambda_.layer_version.absent:
                - name: value
                - layer_name: value
                - version_number: value
    '''

    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.lambda_.layer_version.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.lambda_.get_layer_version(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.lambda_.delete_layer_version(
                ctx,
                
                
                **{"LayerName": layer_name, "VersionNumber": version_number}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.lambda_.get_layer_version(name)
    result["changes"] = differ.deep_diff(before, after)
    return result



async def describe(hub, ctx)  -> Dict[str, Dict[str, Any]]:
    r'''
    **Autogenerated function**

    Describe the resource in a way that can be recreated/managed with the corresponding "present" function

    
    Lists the versions of an Lambda layer. Versions that have been deleted aren't listed. Specify a runtime
    identifier to list only versions that indicate that they're compatible with that runtime.


    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: bash

            $ idem describe aws_auto.lambda_.layer_version
    '''

    
    result = {}

    ret = await hub.exec.boto3.client.lambda_.list_layer_versions(ctx)
    if not ret["status"]:
        hub.log.debug(f"Could not describe layer_version {ret['comment']}")
        return result

    for layer_version in ret["ret"]["TODO"]:
        new_layer_version = [
                {"CompatibleRuntime": compatible_runtime, "LayerName": layer_name, "Marker": marker, "MaxItems": max_items}
        ]
        result[layer_version["layer_versionId"]] = {"aws_auto.lambda_.layer_version.present": new_layer_version}

        for i, data in enumerate(layer_version.get("", ())):
            sub_layer_version = copy.deepcopy(new_layer_version)

            # TODO check for subresouruces
            sub_layer_version.append({})
            sub_layer_version.append({"name": "TODOs"})
            result[f"TODOs-{i}"] = {"aws_auto.lambda_.layer_version.present": sub_layer_version}

    return result


