"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.storagegateway.create_tapes
hub.exec.boto3.client.storagegateway.delete_tape
hub.exec.boto3.client.storagegateway.describe_tapes
hub.exec.boto3.client.storagegateway.list_tapes
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, gateway_arn: Text, tape_size_in_bytes: int, num_tapes_to_create: int, tape_barcode_prefix: Text, kms_encrypted: bool = None, kms_key: Text = None, pool_id: Text = None, worm: bool = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates one or more virtual tapes. You write data to the virtual tapes and then archive the tapes. This
    operation is only supported in the tape gateway type.  Cache storage must be allocated to the gateway before you
    can create virtual tapes. Use the AddCache operation to add cache storage to a gateway.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        gateway_arn(Text): The unique Amazon Resource Name (ARN) that represents the gateway to associate the virtual tapes
            with. Use the ListGateways operation to return a list of gateways for your account and Region.
        tape_size_in_bytes(int): The size, in bytes, of the virtual tapes that you want to create.  The size must be aligned by
            gigabyte (1024*1024*1024 bytes).
        num_tapes_to_create(int): The number of virtual tapes that you want to create.
        tape_barcode_prefix(Text): A prefix that you append to the barcode of the virtual tape you are creating. This prefix makes
            the barcode unique.  The prefix must be 1-4 characters in length and must be one of the
            uppercase letters from A to Z.
        kms_encrypted(bool, optional): Set to true to use Amazon S3 server-side encryption with your own KMS key, or false to use a key
            managed by Amazon S3. Optional. Valid Values: true | false. Defaults to None.
        kms_key(Text, optional): The Amazon Resource Name (ARN) of a symmetric customer master key (CMK) used for Amazon S3
            server-side encryption. Storage Gateway does not support asymmetric CMKs. This value can only be
            set when KMSEncrypted is true. Optional. Defaults to None.
        pool_id(Text, optional): The ID of the pool that you want to add your tape to for archiving. The tape in this pool is
            archived in the S3 storage class that is associated with the pool. When you use your backup
            application to eject the tape, the tape is archived directly into the storage class (S3 Glacier
            or S3 Glacier Deep Archive) that corresponds to the pool. Valid Values: GLACIER | DEEP_ARCHIVE. Defaults to None.
        worm(bool, optional): Set to TRUE if the tape you are creating is to be configured as a write-once-read-many (WORM)
            tape. Defaults to None.
        tags(List, optional): A list of up to 50 tags that can be assigned to a virtual tape. Each tag is a key-value pair.
            Valid characters for key and value are letters, spaces, and numbers representable in UTF-8
            format, and the following special characters: + - = . _ : / @. The maximum length of a tag's key
            is 128 characters, and the maximum length for a tag's value is 256. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.storagegateway.tape.present:
                - name: value
                - gateway_arn: value
                - tape_size_in_bytes: value
                - num_tapes_to_create: value
                - tape_barcode_prefix: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.storagegateway.tape.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.storagegateway.describe_tapes(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.storagegateway.create_tapes(
                ctx,
                
                ClientToken=name,
                **{"GatewayARN": gateway_arn, "TapeSizeInBytes": tape_size_in_bytes, "NumTapesToCreate": num_tapes_to_create, "TapeBarcodePrefix": tape_barcode_prefix, "KMSEncrypted": kms_encrypted, "KMSKey": kms_key, "PoolId": pool_id, "Worm": worm, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.storagegateway.describe_tapes(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, gateway_arn: Text, tape_arn: Text, bypass_governance_retention: bool = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified virtual tape. This operation is only supported in the tape gateway type.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        gateway_arn(Text): The unique Amazon Resource Name (ARN) of the gateway that the virtual tape to delete is
            associated with. Use the ListGateways operation to return a list of gateways for your account
            and Region.
        tape_arn(Text): The Amazon Resource Name (ARN) of the virtual tape to delete.
        bypass_governance_retention(bool, optional): Set to TRUE to delete an archived tape that belongs to a custom pool with tape retention lock.
            Only archived tapes with tape retention lock set to governance can be deleted. Archived tapes
            with tape retention lock set to compliance can't be deleted. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.storagegateway.tape.absent:
                - name: value
                - gateway_arn: value
                - tape_arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.storagegateway.tape.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.storagegateway.describe_tapes(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.storagegateway.delete_tape(
                ctx,
                
                
                **{"GatewayARN": gateway_arn, "TapeARN": tape_arn, "BypassGovernanceRetention": bypass_governance_retention}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.storagegateway.describe_tapes(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

