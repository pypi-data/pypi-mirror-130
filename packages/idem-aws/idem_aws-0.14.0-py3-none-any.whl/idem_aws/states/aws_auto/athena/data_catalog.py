"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.athena.create_data_catalog
hub.exec.boto3.client.athena.delete_data_catalog
hub.exec.boto3.client.athena.get_data_catalog
hub.exec.boto3.client.athena.list_data_catalogs
hub.exec.boto3.client.athena.update_data_catalog
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, type_: Text, description: Text = None, parameters: Dict = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates (registers) a data catalog with the specified name and properties. Catalogs created are visible to all
    users of the same Amazon Web Services account.

    Args:
        name(Text): The name of the data catalog to create. The catalog name must be unique for the Amazon Web
            Services account and can use a maximum of 128 alphanumeric, underscore, at sign, or hyphen
            characters.
        type_(Text): The type of data catalog to create: LAMBDA for a federated catalog, HIVE for an external hive
            metastore, or GLUE for an Glue Data Catalog.
        description(Text, optional): A description of the data catalog to be created. Defaults to None.
        parameters(Dict, optional): Specifies the Lambda function or functions to use for creating the data catalog. This is a
            mapping whose values depend on the catalog type.    For the HIVE data catalog type, use the
            following syntax. The metadata-function parameter is required. The sdk-version parameter is
            optional and defaults to the currently supported version.  metadata-function=lambda_arn, sdk-
            version=version_number     For the LAMBDA data catalog type, use one of the following sets of
            required parameters, but not both.   If you have one Lambda function that processes metadata and
            another for reading the actual data, use the following syntax. Both parameters are required.
            metadata-function=lambda_arn, record-function=lambda_arn      If you have a composite Lambda
            function that processes both metadata and data, use the following syntax to specify your Lambda
            function.  function=lambda_arn       The GLUE type takes a catalog ID parameter and is required.
            The  catalog_id  is the account ID of the Amazon Web Services account to which the Glue Data
            Catalog belongs.  catalog-id=catalog_id     The GLUE data catalog type also applies to the
            default AwsDataCatalog that already exists in your account, of which you can have only one and
            cannot modify.   Queries that specify a Glue Data Catalog other than the default AwsDataCatalog
            must be run on Athena engine version 2.   In Regions where Athena engine version 2 is not
            available, creating new Glue data catalogs results in an INVALID_INPUT error. Defaults to None.
        tags(List, optional): A list of comma separated tags to add to the data catalog that is created. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.athena.data_catalog.present:
                - name: value
                - type_: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.athena.data_catalog.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.athena.get_data_catalog(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.athena.create_data_catalog(
                ctx,
                
                
                **{"Name": name, "Type": type_, "Description": description, "Parameters": parameters, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.athena.get_data_catalog(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a data catalog.

    Args:
        name(Text): The name of the data catalog to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.athena.data_catalog.absent:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.athena.data_catalog.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.athena.get_data_catalog(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.athena.delete_data_catalog(
                ctx,
                
                
                **{"Name": name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.athena.get_data_catalog(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

