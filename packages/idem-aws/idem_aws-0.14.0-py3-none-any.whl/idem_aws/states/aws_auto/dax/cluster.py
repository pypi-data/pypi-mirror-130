"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.dax.create_cluster
hub.exec.boto3.client.dax.delete_cluster
hub.exec.boto3.client.dax.describe_clusters
hub.exec.boto3.client.dax.update_cluster
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, cluster_name: Text, node_type: Text, replication_factor: int, iam_role_arn: Text, description: Text = None, availability_zones: List = None, subnet_group_name: Text = None, security_group_ids: List = None, preferred_maintenance_window: Text = None, notification_topic_arn: Text = None, parameter_group_name: Text = None, tags: List = None, sse_specification: Dict = None, cluster_endpoint_encryption_type: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a DAX cluster. All nodes in the cluster run the same DAX caching software.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        cluster_name(Text): The cluster identifier. This parameter is stored as a lowercase string.  Constraints:    A name
            must contain from 1 to 20 alphanumeric characters or hyphens.   The first character must be a
            letter.   A name cannot end with a hyphen or contain two consecutive hyphens.
        node_type(Text): The compute and memory capacity of the nodes in the cluster.
        description(Text, optional): A description of the cluster. Defaults to None.
        replication_factor(int): The number of nodes in the DAX cluster. A replication factor of 1 will create a single-node
            cluster, without any read replicas. For additional fault tolerance, you can create a multiple
            node cluster with one or more read replicas. To do this, set ReplicationFactor to a number
            between 3 (one primary and two read replicas) and 10 (one primary and nine read replicas). If
            the AvailabilityZones parameter is provided, its length must equal the ReplicationFactor.  AWS
            recommends that you have at least two read replicas per cluster.
        availability_zones(List, optional): The Availability Zones (AZs) in which the cluster nodes will reside after the cluster has been
            created or updated. If provided, the length of this list must equal the ReplicationFactor
            parameter. If you omit this parameter, DAX will spread the nodes across Availability Zones for
            the highest availability. Defaults to None.
        subnet_group_name(Text, optional): The name of the subnet group to be used for the replication group.  DAX clusters can only run in
            an Amazon VPC environment. All of the subnets that you specify in a subnet group must exist in
            the same VPC. Defaults to None.
        security_group_ids(List, optional): A list of security group IDs to be assigned to each node in the DAX cluster. (Each of the
            security group ID is system-generated.) If this parameter is not specified, DAX assigns the
            default VPC security group to each node. Defaults to None.
        preferred_maintenance_window(Text, optional): Specifies the weekly time range during which maintenance on the DAX cluster is performed. It is
            specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum
            maintenance window is a 60 minute period. Valid values for ddd are:    sun     mon     tue
            wed     thu     fri     sat    Example: sun:05:00-sun:09:00   If you don't specify a preferred
            maintenance window when you create or modify a cache cluster, DAX assigns a 60-minute
            maintenance window on a randomly selected day of the week. Defaults to None.
        notification_topic_arn(Text, optional): The Amazon Resource Name (ARN) of the Amazon SNS topic to which notifications will be sent.  The
            Amazon SNS topic owner must be same as the DAX cluster owner. Defaults to None.
        iam_role_arn(Text): A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX will assume this
            role and use the role's permissions to access DynamoDB on your behalf.
        parameter_group_name(Text, optional): The parameter group to be associated with the DAX cluster. Defaults to None.
        tags(List, optional): A set of tags to associate with the DAX cluster. Defaults to None.
        sse_specification(Dict, optional): Represents the settings used to enable server-side encryption on the cluster. Defaults to None.
        cluster_endpoint_encryption_type(Text, optional): The type of encryption the cluster's endpoint should support. Values are:    NONE for no
            encryption    TLS for Transport Layer Security. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.dax.cluster.present:
                - name: value
                - cluster_name: value
                - node_type: value
                - replication_factor: value
                - iam_role_arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.dax.cluster.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.dax.describe_clusters(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.dax.create_cluster(
                ctx,
                
                
                **{"ClusterName": cluster_name, "NodeType": node_type, "Description": description, "ReplicationFactor": replication_factor, "AvailabilityZones": availability_zones, "SubnetGroupName": subnet_group_name, "SecurityGroupIds": security_group_ids, "PreferredMaintenanceWindow": preferred_maintenance_window, "NotificationTopicArn": notification_topic_arn, "IamRoleArn": iam_role_arn, "ParameterGroupName": parameter_group_name, "Tags": tags, "SSESpecification": sse_specification, "ClusterEndpointEncryptionType": cluster_endpoint_encryption_type}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.dax.describe_clusters(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, cluster_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a previously provisioned DAX cluster. DeleteCluster deletes all associated nodes, node endpoints and the
    DAX cluster itself. When you receive a successful response from this action, DAX immediately begins deleting the
    cluster; you cannot cancel or revert this action.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        cluster_name(Text): The name of the cluster to be deleted.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.dax.cluster.absent:
                - name: value
                - cluster_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.dax.cluster.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.dax.describe_clusters(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.dax.delete_cluster(
                ctx,
                
                
                **{"ClusterName": cluster_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.dax.describe_clusters(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

