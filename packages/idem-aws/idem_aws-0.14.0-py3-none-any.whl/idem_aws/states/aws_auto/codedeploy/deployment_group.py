"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.codedeploy.create_deployment_group
hub.exec.boto3.client.codedeploy.delete_deployment_group
hub.exec.boto3.client.codedeploy.get_deployment_group
hub.exec.boto3.client.codedeploy.list_deployment_groups
hub.exec.boto3.client.codedeploy.update_deployment_group
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, application_name: Text, deployment_group_name: Text, service_role_arn: Text, deployment_config_name: Text = None, ec2_tag_filters: List = None, on_premises_instance_tag_filters: List = None, auto_scaling_groups: List = None, trigger_configurations: List = None, alarm_configuration: Dict = None, auto_rollback_configuration: Dict = None, outdated_instances_strategy: Text = None, deployment_style: Dict = None, blue_green_deployment_configuration: Dict = None, load_balancer_info: Dict = None, ec2_tag_set: Dict = None, ecs_services: List = None, on_premises_tag_set: Dict = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a deployment group to which application revisions are deployed.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        application_name(Text): The name of an AWS CodeDeploy application associated with the IAM user or AWS account.
        deployment_group_name(Text): The name of a new deployment group for the specified application.
        deployment_config_name(Text, optional): If specified, the deployment configuration name can be either one of the predefined
            configurations provided with AWS CodeDeploy or a custom deployment configuration that you create
            by calling the create deployment configuration operation.  CodeDeployDefault.OneAtATime is the
            default deployment configuration. It is used if a configuration isn't specified for the
            deployment or deployment group. For more information about the predefined deployment
            configurations in AWS CodeDeploy, see Working with Deployment Configurations in CodeDeploy in
            the AWS CodeDeploy User Guide. Defaults to None.
        ec2_tag_filters(List, optional): The Amazon EC2 tags on which to filter. The deployment group includes EC2 instances with any of
            the specified tags. Cannot be used in the same call as ec2TagSet. Defaults to None.
        on_premises_instance_tag_filters(List, optional): The on-premises instance tags on which to filter. The deployment group includes on-premises
            instances with any of the specified tags. Cannot be used in the same call as OnPremisesTagSet. Defaults to None.
        auto_scaling_groups(List, optional): A list of associated Amazon EC2 Auto Scaling groups. Defaults to None.
        service_role_arn(Text): A service role Amazon Resource Name (ARN) that allows AWS CodeDeploy to act on the user's behalf
            when interacting with AWS services.
        trigger_configurations(List, optional): Information about triggers to create when the deployment group is created. For examples, see
            Create a Trigger for an AWS CodeDeploy Event in the AWS CodeDeploy User Guide. Defaults to None.
        alarm_configuration(Dict, optional): Information to add about Amazon CloudWatch alarms when the deployment group is created. Defaults to None.
        auto_rollback_configuration(Dict, optional): Configuration information for an automatic rollback that is added when a deployment group is
            created. Defaults to None.
        outdated_instances_strategy(Text, optional): Indicates what happens when new EC2 instances are launched mid-deployment and do not receive the
            deployed application revision. If this option is set to UPDATE or is unspecified, CodeDeploy
            initiates one or more 'auto-update outdated instances' deployments to apply the deployed
            application revision to the new EC2 instances. If this option is set to IGNORE, CodeDeploy does
            not initiate a deployment to update the new EC2 instances. This may result in instances having
            different revisions. Defaults to None.
        deployment_style(Dict, optional): Information about the type of deployment, in-place or blue/green, that you want to run and
            whether to route deployment traffic behind a load balancer. Defaults to None.
        blue_green_deployment_configuration(Dict, optional): Information about blue/green deployment options for a deployment group. Defaults to None.
        load_balancer_info(Dict, optional): Information about the load balancer used in a deployment. Defaults to None.
        ec2_tag_set(Dict, optional): Information about groups of tags applied to EC2 instances. The deployment group includes only
            EC2 instances identified by all the tag groups. Cannot be used in the same call as
            ec2TagFilters. Defaults to None.
        ecs_services(List, optional):  The target Amazon ECS services in the deployment group. This applies only to deployment groups
            that use the Amazon ECS compute platform. A target Amazon ECS service is specified as an Amazon
            ECS cluster and service name pair using the format <clustername>:<servicename>. Defaults to None.
        on_premises_tag_set(Dict, optional): Information about groups of tags applied to on-premises instances. The deployment group includes
            only on-premises instances identified by all of the tag groups. Cannot be used in the same call
            as onPremisesInstanceTagFilters. Defaults to None.
        tags(List, optional):  The metadata that you apply to CodeDeploy deployment groups to help you organize and categorize
            them. Each tag consists of a key and an optional value, both of which you define. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.codedeploy.deployment_group.present:
                - name: value
                - application_name: value
                - deployment_group_name: value
                - service_role_arn: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.codedeploy.deployment_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.codedeploy.get_deployment_group(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.codedeploy.create_deployment_group(
                ctx,
                
                
                **{"applicationName": application_name, "deploymentGroupName": deployment_group_name, "deploymentConfigName": deployment_config_name, "ec2TagFilters": ec2_tag_filters, "onPremisesInstanceTagFilters": on_premises_instance_tag_filters, "autoScalingGroups": auto_scaling_groups, "serviceRoleArn": service_role_arn, "triggerConfigurations": trigger_configurations, "alarmConfiguration": alarm_configuration, "autoRollbackConfiguration": auto_rollback_configuration, "outdatedInstancesStrategy": outdated_instances_strategy, "deploymentStyle": deployment_style, "blueGreenDeploymentConfiguration": blue_green_deployment_configuration, "loadBalancerInfo": load_balancer_info, "ec2TagSet": ec2_tag_set, "ecsServices": ecs_services, "onPremisesTagSet": on_premises_tag_set, "tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.codedeploy.get_deployment_group(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, application_name: Text, deployment_group_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a deployment group.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        application_name(Text): The name of an AWS CodeDeploy application associated with the IAM user or AWS account.
        deployment_group_name(Text): The name of a deployment group for the specified application.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.codedeploy.deployment_group.absent:
                - name: value
                - application_name: value
                - deployment_group_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.codedeploy.deployment_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.codedeploy.get_deployment_group(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.codedeploy.delete_deployment_group(
                ctx,
                
                
                **{"applicationName": application_name, "deploymentGroupName": deployment_group_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.codedeploy.get_deployment_group(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

