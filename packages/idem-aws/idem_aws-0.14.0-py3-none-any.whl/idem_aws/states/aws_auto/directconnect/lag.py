"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.directconnect.create_lag
hub.exec.boto3.client.directconnect.delete_lag
hub.exec.boto3.client.directconnect.describe_lags
hub.exec.boto3.client.directconnect.update_lag
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, number_of_connections: int, location: Text, connections_bandwidth: Text, lag_name: Text, connection_id: Text = None, tags: List = None, child_connection_tags: List = None, provider_name: Text = None, request_mac_sec: bool = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a link aggregation group (LAG) with the specified number of bundled physical dedicated connections
    between the customer network and a specific Direct Connect location. A LAG is a logical interface that uses the
    Link Aggregation Control Protocol (LACP) to aggregate multiple interfaces, enabling you to treat them as a
    single interface. All connections in a LAG must use the same bandwidth (either 1Gbps or 10Gbps) and must
    terminate at the same Direct Connect endpoint. You can have up to 10 dedicated connections per LAG. Regardless
    of this limit, if you request more connections for the LAG than Direct Connect can allocate on a single
    endpoint, no LAG is created. You can specify an existing physical dedicated connection or interconnect to
    include in the LAG (which counts towards the total number of connections). Doing so interrupts the current
    physical dedicated connection, and re-establishes them as a member of the LAG. The LAG will be created on the
    same Direct Connect endpoint to which the dedicated connection terminates. Any virtual interfaces associated
    with the dedicated connection are automatically disassociated and re-associated with the LAG. The connection ID
    does not change. If the account used to create a LAG is a registered Direct Connect Partner, the LAG is
    automatically enabled to host sub-connections. For a LAG owned by a partner, any associated virtual interfaces
    cannot be directly configured.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        number_of_connections(int): The number of physical dedicated connections initially provisioned and bundled by the LAG.
        location(Text): The location for the LAG.
        connections_bandwidth(Text): The bandwidth of the individual physical dedicated connections bundled by the LAG. The possible
            values are 1Gbps and 10Gbps.
        lag_name(Text): The name of the LAG.
        connection_id(Text, optional): The ID of an existing dedicated connection to migrate to the LAG. Defaults to None.
        tags(List, optional): The tags to associate with the LAG. Defaults to None.
        child_connection_tags(List, optional): The tags to associate with the automtically created LAGs. Defaults to None.
        provider_name(Text, optional): The name of the service provider associated with the LAG. Defaults to None.
        request_mac_sec(bool, optional): Indicates whether the connection will support MAC Security (MACsec).  All connections in the LAG
            must be capable of supporting MAC Security (MACsec). For information about MAC Security (MACsec)
            prerequisties, see MACsec prerequisties in the Direct Connect User Guide. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.directconnect.lag.present:
                - name: value
                - number_of_connections: value
                - location: value
                - connections_bandwidth: value
                - lag_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.directconnect.lag.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.directconnect.describe_lags(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.directconnect.create_lag(
                ctx,
                
                
                **{"numberOfConnections": number_of_connections, "location": location, "connectionsBandwidth": connections_bandwidth, "lagName": lag_name, "connectionId": connection_id, "tags": tags, "childConnectionTags": child_connection_tags, "providerName": provider_name, "requestMACSec": request_mac_sec}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.directconnect.describe_lags(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, lag_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified link aggregation group (LAG). You cannot delete a LAG if it has active virtual interfaces
    or hosted connections.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        lag_id(Text): The ID of the LAG.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.directconnect.lag.absent:
                - name: value
                - lag_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.directconnect.lag.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.directconnect.describe_lags(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.directconnect.delete_lag(
                ctx,
                
                
                **{"lagId": lag_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.directconnect.describe_lags(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

