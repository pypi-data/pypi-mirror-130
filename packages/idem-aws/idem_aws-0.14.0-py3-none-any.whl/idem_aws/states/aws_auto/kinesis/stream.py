"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.kinesis.create_stream
hub.exec.boto3.client.kinesis.delete_stream
hub.exec.boto3.client.kinesis.describe_stream
hub.exec.boto3.client.kinesis.list_streams
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, stream_name: Text, shard_count: int)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a Kinesis data stream. A stream captures and transports data records that are continuously emitted from
    different data sources or producers. Scale-out within a stream is explicitly supported by means of shards, which
    are uniquely identified groups of data records in a stream. You specify and control the number of shards that a
    stream is composed of. Each shard can support reads up to five transactions per second, up to a maximum data
    read total of 2 MiB per second. Each shard can support writes up to 1,000 records per second, up to a maximum
    data write total of 1 MiB per second. If the amount of data input increases or decreases, you can add or remove
    shards. The stream name identifies the stream. The name is scoped to the AWS account used by the application. It
    is also scoped by AWS Region. That is, two streams in two different accounts can have the same name, and two
    streams in the same account, but in two different Regions, can have the same name.  CreateStream is an
    asynchronous operation. Upon receiving a CreateStream request, Kinesis Data Streams immediately returns and sets
    the stream status to CREATING. After the stream is created, Kinesis Data Streams sets the stream status to
    ACTIVE. You should perform read and write operations only on an ACTIVE stream.  You receive a
    LimitExceededException when making a CreateStream request when you try to do one of the following:   Have more
    than five streams in the CREATING state at any point in time.   Create more shards than are authorized for your
    account.   For the default shard limit for an AWS account, see Amazon Kinesis Data Streams Limits in the Amazon
    Kinesis Data Streams Developer Guide. To increase this limit, contact AWS Support. You can use DescribeStream to
    check the stream status, which is returned in StreamStatus.  CreateStream has a limit of five transactions per
    second per account.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        stream_name(Text): A name to identify the stream. The stream name is scoped to the AWS account used by the
            application that creates the stream. It is also scoped by AWS Region. That is, two streams in
            two different AWS accounts can have the same name. Two streams in the same AWS account but in
            two different Regions can also have the same name.
        shard_count(int): The number of shards that the stream will use. The throughput of the stream is a function of the
            number of shards; more shards are required for greater provisioned throughput.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.kinesis.stream.present:
                - name: value
                - stream_name: value
                - shard_count: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.kinesis.stream.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.kinesis.describe_stream(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.kinesis.create_stream(
                ctx,
                
                
                **{"StreamName": stream_name, "ShardCount": shard_count}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.kinesis.describe_stream(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, stream_name: Text, enforce_consumer_deletion: bool = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a Kinesis data stream and all its shards and data. You must shut down any applications that are
    operating on the stream before you delete the stream. If an application attempts to operate on a deleted stream,
    it receives the exception ResourceNotFoundException. If the stream is in the ACTIVE state, you can delete it.
    After a DeleteStream request, the specified stream is in the DELETING state until Kinesis Data Streams completes
    the deletion.  Note: Kinesis Data Streams might continue to accept data read and write operations, such as
    PutRecord, PutRecords, and GetRecords, on a stream in the DELETING state until the stream deletion is complete.
    When you delete a stream, any shards in that stream are also deleted, and any tags are dissociated from the
    stream. You can use the DescribeStream operation to check the state of the stream, which is returned in
    StreamStatus.  DeleteStream has a limit of five transactions per second per account.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        stream_name(Text): The name of the stream to delete.
        enforce_consumer_deletion(bool, optional): If this parameter is unset (null) or if you set it to false, and the stream has registered
            consumers, the call to DeleteStream fails with a ResourceInUseException. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.kinesis.stream.absent:
                - name: value
                - stream_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.kinesis.stream.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.kinesis.describe_stream(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.kinesis.delete_stream(
                ctx,
                
                
                **{"StreamName": stream_name, "EnforceConsumerDeletion": enforce_consumer_deletion}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.kinesis.describe_stream(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

