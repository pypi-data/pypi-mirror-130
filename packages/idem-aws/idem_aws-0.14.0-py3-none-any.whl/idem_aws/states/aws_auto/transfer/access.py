"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.transfer.create_access
hub.exec.boto3.client.transfer.delete_access
hub.exec.boto3.client.transfer.describe_access
hub.exec.boto3.client.transfer.list_accesses
hub.exec.boto3.client.transfer.update_access
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, role: Text, server_id: Text, external_id: Text, home_directory: Text = None, home_directory_type: Text = None, home_directory_mappings: List = None, policy: Text = None, posix_profile: Dict = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Used by administrators to choose which groups in the directory should have access to upload and download files
    over the enabled protocols using Amazon Web Services Transfer Family. For example, a Microsoft Active Directory
    might contain 50,000 users, but only a small fraction might need the ability to transfer files to the server. An
    administrator can use CreateAccess to limit the access to the correct set of users who need this ability.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        home_directory(Text, optional): The landing directory (folder) for a user when they log in to the server using the client. A
            HomeDirectory example is /bucket_name/home/mydirectory. Defaults to None.
        home_directory_type(Text, optional): The type of landing directory (folder) you want your users' home directory to be when they log
            into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS
            paths as is in their file transfer protocol clients. If you set it LOGICAL, you will need to
            provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths
            visible to your users. Defaults to None.
        home_directory_mappings(List, optional): Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be
            visible to your user and how you want to make them visible. You must specify the Entry and
            Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3
            or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure
            that your Amazon Web Services Identity and Access Management (IAM) role provides access to paths
            in Target. This value can only be set when HomeDirectoryType is set to LOGICAL. The following is
            an Entry and Target pair example.  [ { "Entry": "your-personal-report.pdf", "Target":
            "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]  In most cases, you can use this
            value instead of the scope-down policy to lock down your user to the designated home directory
            ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter
            value. The following is an Entry and Target pair example for chroot.  [ { "Entry:": "/",
            "Target": "/bucket_name/home/mydirectory" } ]   If the target of a logical directory entry does
            not exist in Amazon S3 or EFS, the entry is ignored. As a workaround, you can use the Amazon S3
            API or EFS API to create 0 byte objects as place holders for your directory. If using the CLI,
            use the s3api or efsapi call instead of s3 or efs so you can use the put-object operation. For
            example, you use the following: aws s3api put-object --bucket bucketname --key path/to/folder/.
            Make sure that the end of the key name ends in a / for it to be considered a folder. Defaults to None.
        policy(Text, optional): A scope-down policy for your user so that you can use the same IAM role across multiple users.
            This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you
            can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and
            ${Transfer:HomeBucket}.  This only applies when domain of ServerId is S3. Amazon EFS does not
            use scope-down policies. For scope-down policies, Amazon Web Services Transfer Family stores the
            policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the
            policy as a JSON blob and pass it in the Policy argument. For an example of a scope-down policy,
            see Example scope-down policy. For more information, see AssumeRole in the Amazon Web Services
            Security Token Service API Reference. Defaults to None.
        posix_profile(Dict, optional): The full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary groups IDs
            (SecondaryGids), that controls your users' access to your Amazon EFS file systems. The POSIX
            permissions that are set on files and directories in your file system determine the level of
            access your users get when transferring files into and out of your Amazon EFS file systems. Defaults to None.
        role(Text): Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to
            your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level
            of access that you want to provide your users when transferring files into and out of your
            Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that
            allows the server to access your resources when servicing your users' transfer requests.
        server_id(Text): A system-assigned unique identifier for a server instance. This is the specific server that you
            added your user to.
        external_id(Text): A unique identifier that is required to identify specific groups within your directory. The
            users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over
            the enabled protocols using Amazon Web Services Transfer Family. If you know the group name, you
            can view the SID values by running the following command using Windows PowerShell.  Get-ADGroup
            -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid
            In that command, replace YourGroupName with the name of your Active Directory group. The regex
            used to validate this parameter is a string of characters consisting of uppercase and lowercase
            alphanumeric characters with no spaces. You can also include underscores or any of the following
            characters: =,.@:/-.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.transfer.access.present:
                - name: value
                - role: value
                - server_id: value
                - external_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.transfer.access.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.transfer.describe_access(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.transfer.create_access(
                ctx,
                
                
                **{"HomeDirectory": home_directory, "HomeDirectoryType": home_directory_type, "HomeDirectoryMappings": home_directory_mappings, "Policy": policy, "PosixProfile": posix_profile, "Role": role, "ServerId": server_id, "ExternalId": external_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.transfer.describe_access(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, server_id: Text, external_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Allows you to delete the access specified in the ServerID and ExternalID parameters.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        server_id(Text): A system-assigned unique identifier for a server that has this user assigned.
        external_id(Text): A unique identifier that is required to identify specific groups within your directory. The
            users of the group that you associate have access to your Amazon S3 or Amazon EFS resources over
            the enabled protocols using Amazon Web Services Transfer Family. If you know the group name, you
            can view the SID values by running the following command using Windows PowerShell.  Get-ADGroup
            -Filter {samAccountName -like "YourGroupName*"} -Properties * | Select SamAccountName,ObjectSid
            In that command, replace YourGroupName with the name of your Active Directory group. The regex
            used to validate this parameter is a string of characters consisting of uppercase and lowercase
            alphanumeric characters with no spaces. You can also include underscores or any of the following
            characters: =,.@:/-.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.transfer.access.absent:
                - name: value
                - server_id: value
                - external_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.transfer.access.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.transfer.describe_access(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.transfer.delete_access(
                ctx,
                
                
                **{"ServerId": server_id, "ExternalId": external_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.transfer.describe_access(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

