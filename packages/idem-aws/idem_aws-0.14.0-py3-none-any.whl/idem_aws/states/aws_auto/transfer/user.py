"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.transfer.create_user
hub.exec.boto3.client.transfer.delete_user
hub.exec.boto3.client.transfer.describe_user
hub.exec.boto3.client.transfer.list_users
hub.exec.boto3.client.transfer.update_user
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, role: Text, server_id: Text, user_name: Text, home_directory: Text = None, home_directory_type: Text = None, home_directory_mappings: List = None, policy: Text = None, posix_profile: Dict = None, ssh_public_key_body: Text = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a user and associates them with an existing file transfer protocol-enabled server. You can only create
    and associate users with servers that have the IdentityProviderType set to SERVICE_MANAGED. Using parameters for
    CreateUser, you can specify the user name, set the home directory, store the user's public key, and assign the
    user's Amazon Web Services Identity and Access Management (IAM) role. You can also optionally add a scope-down
    policy, and assign metadata with tags that can be used to group and search for users.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        home_directory(Text, optional): The landing directory (folder) for a user when they log in to the server using the client. A
            HomeDirectory example is /bucket_name/home/mydirectory. Defaults to None.
        home_directory_type(Text, optional): The type of landing directory (folder) you want your users' home directory to be when they log
            into the server. If you set it to PATH, the user will see the absolute Amazon S3 bucket or EFS
            paths as is in their file transfer protocol clients. If you set it LOGICAL, you will need to
            provide mappings in the HomeDirectoryMappings for how you want to make Amazon S3 or EFS paths
            visible to your users. Defaults to None.
        home_directory_mappings(List, optional): Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be
            visible to your user and how you want to make them visible. You must specify the Entry and
            Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3
            or Amazon EFS path. If you only specify a target, it is displayed as is. You also must ensure
            that your Amazon Web Services Identity and Access Management (IAM) role provides access to paths
            in Target. This value can only be set when HomeDirectoryType is set to LOGICAL. The following is
            an Entry and Target pair example.  [ { "Entry": "your-personal-report.pdf", "Target":
            "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]  In most cases, you can use this
            value instead of the scope-down policy to lock your user down to the designated home directory
            ("chroot"). To do this, you can set Entry to / and set Target to the HomeDirectory parameter
            value. The following is an Entry and Target pair example for chroot.  [ { "Entry:": "/",
            "Target": "/bucket_name/home/mydirectory" } ]   If the target of a logical directory entry does
            not exist in Amazon S3 or EFS, the entry is ignored. As a workaround, you can use the Amazon S3
            API or EFS API to create 0 byte objects as place holders for your directory. If using the CLI,
            use the s3api or efsapi call instead of s3 or efs so you can use the put-object operation. For
            example, you use the following: aws s3api put-object --bucket bucketname --key path/to/folder/.
            Make sure that the end of the key name ends in a / for it to be considered a folder. Defaults to None.
        policy(Text, optional): A scope-down policy for your user so that you can use the same IAM role across multiple users.
            This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you
            can use inside this policy include ${Transfer:UserName}, ${Transfer:HomeDirectory}, and
            ${Transfer:HomeBucket}.  This only applies when domain of ServerId is S3. EFS does not use scope
            down policy. For scope-down policies, Amazon Web Services Transfer Family stores the policy as a
            JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a
            JSON blob and pass it in the Policy argument. For an example of a scope-down policy, see Example
            scope-down policy. For more information, see AssumeRole in the Amazon Web Services Security
            Token Service API Reference. Defaults to None.
        posix_profile(Dict, optional): Specifies the full POSIX identity, including user ID (Uid), group ID (Gid), and any secondary
            groups IDs (SecondaryGids), that controls your users' access to your Amazon EFS file systems.
            The POSIX permissions that are set on files and directories in Amazon EFS determine the level of
            access your users get when transferring files into and out of your Amazon EFS file systems. Defaults to None.
        role(Text): Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to
            your Amazon S3 bucket or EFS file system. The policies attached to this role determine the level
            of access that you want to provide your users when transferring files into and out of your
            Amazon S3 bucket or EFS file system. The IAM role should also contain a trust relationship that
            allows the server to access your resources when servicing your users' transfer requests.
        server_id(Text): A system-assigned unique identifier for a server instance. This is the specific server that you
            added your user to.
        ssh_public_key_body(Text, optional): The public portion of the Secure Shell (SSH) key used to authenticate the user to the server. Defaults to None.
        tags(List, optional): Key-value pairs that can be used to group and search for users. Tags are metadata attached to
            users for any purpose. Defaults to None.
        user_name(Text): A unique string that identifies a user and is associated with a as specified by the ServerId.
            This user name must be a minimum of 3 and a maximum of 100 characters long. The following are
            valid characters: a-z, A-Z, 0-9, underscore '_', hyphen '-', period '.', and at sign '@'. The
            user name can't start with a hyphen, period, or at sign.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.transfer.user.present:
                - name: value
                - role: value
                - server_id: value
                - user_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.transfer.user.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.transfer.describe_user(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.transfer.create_user(
                ctx,
                
                
                **{"HomeDirectory": home_directory, "HomeDirectoryType": home_directory_type, "HomeDirectoryMappings": home_directory_mappings, "Policy": policy, "PosixProfile": posix_profile, "Role": role, "ServerId": server_id, "SshPublicKeyBody": ssh_public_key_body, "Tags": tags, "UserName": user_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.transfer.describe_user(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, server_id: Text, user_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the user belonging to a file transfer protocol-enabled server you specify. No response returns from this
    operation.  When you delete a user from a server, the user's information is lost.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        server_id(Text): A system-assigned unique identifier for a server instance that has the user assigned to it.
        user_name(Text): A unique string that identifies a user that is being deleted from a server.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.transfer.user.absent:
                - name: value
                - server_id: value
                - user_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.transfer.user.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.transfer.describe_user(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.transfer.delete_user(
                ctx,
                
                
                **{"ServerId": server_id, "UserName": user_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.transfer.describe_user(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

