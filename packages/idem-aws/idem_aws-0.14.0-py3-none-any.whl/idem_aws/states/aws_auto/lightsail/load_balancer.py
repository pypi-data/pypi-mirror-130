"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.lightsail.create_load_balancer
hub.exec.boto3.client.lightsail.delete_load_balancer
hub.exec.boto3.client.lightsail.get_load_balancers
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, load_balancer_name: Text, instance_port: int, health_check_path: Text = None, certificate_name: Text = None, certificate_domain_name: Text = None, certificate_alternative_names: List = None, tags: List = None, ip_address_type: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a Lightsail load balancer. To learn more about deciding whether to load balance your application, see
    Configure your Lightsail instances for load balancing. You can create up to 5 load balancers per AWS Region in
    your account. When you create a load balancer, you can specify a unique name and port settings. To change
    additional load balancer settings, use the UpdateLoadBalancerAttribute operation. The create load balancer
    operation supports tag-based access control via request tags. For more information, see the Amazon Lightsail
    Developer Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        load_balancer_name(Text): The name of your load balancer.
        instance_port(int): The instance port where you're creating your load balancer.
        health_check_path(Text, optional): The path you provided to perform the load balancer health check. If you didn't specify a health
            check path, Lightsail uses the root path of your website (e.g., "/"). You may want to specify a
            custom health check path other than the root of your application if your home page loads slowly
            or has a lot of media or scripting on it. Defaults to None.
        certificate_name(Text, optional): The name of the SSL/TLS certificate. If you specify certificateName, then certificateDomainName
            is required (and vice-versa). Defaults to None.
        certificate_domain_name(Text, optional): The domain name with which your certificate is associated (e.g., example.com). If you specify
            certificateDomainName, then certificateName is required (and vice-versa). Defaults to None.
        certificate_alternative_names(List, optional): The optional alternative domains and subdomains to use with your SSL/TLS certificate (e.g.,
            www.example.com, example.com, m.example.com, blog.example.com). Defaults to None.
        tags(List, optional): The tag keys and optional values to add to the resource during create. Use the TagResource
            action to tag a resource after it's created. Defaults to None.
        ip_address_type(Text, optional): The IP address type for the load balancer. The possible values are ipv4 for IPv4 only, and
            dualstack for IPv4 and IPv6. The default value is dualstack. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.lightsail.load_balancer.present:
                - name: value
                - load_balancer_name: value
                - instance_port: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.lightsail.load_balancer.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.lightsail.get_load_balancers(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.lightsail.create_load_balancer(
                ctx,
                
                
                **{"loadBalancerName": load_balancer_name, "instancePort": instance_port, "healthCheckPath": health_check_path, "certificateName": certificate_name, "certificateDomainName": certificate_domain_name, "certificateAlternativeNames": certificate_alternative_names, "tags": tags, "ipAddressType": ip_address_type}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.lightsail.get_load_balancers(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, load_balancer_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a Lightsail load balancer and all its associated SSL/TLS certificates. Once the load balancer is
    deleted, you will need to create a new load balancer, create a new certificate, and verify domain ownership
    again. The delete load balancer operation supports tag-based access control via resource tags applied to the
    resource identified by load balancer name. For more information, see the Amazon Lightsail Developer Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        load_balancer_name(Text): The name of the load balancer you want to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.lightsail.load_balancer.absent:
                - name: value
                - load_balancer_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.lightsail.load_balancer.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.lightsail.get_load_balancers(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.lightsail.delete_load_balancer(
                ctx,
                
                
                **{"loadBalancerName": load_balancer_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.lightsail.get_load_balancers(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

