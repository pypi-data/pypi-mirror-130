"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.cognito_idp.create_user_pool
hub.exec.boto3.client.cognito_idp.delete_user_pool
hub.exec.boto3.client.cognito_idp.describe_user_pool
hub.exec.boto3.client.cognito_idp.list_user_pools
hub.exec.boto3.client.cognito_idp.update_user_pool
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, pool_name: Text, policies: Dict = None, lambda_config: Dict = None, auto_verified_attributes: List = None, alias_attributes: List = None, username_attributes: List = None, sms_verification_message: Text = None, email_verification_message: Text = None, email_verification_subject: Text = None, verification_message_template: Dict = None, sms_authentication_message: Text = None, mfa_configuration: Text = None, device_configuration: Dict = None, email_configuration: Dict = None, sms_configuration: Dict = None, user_pool_tags: Dict = None, admin_create_user_config: Dict = None, schema: List = None, user_pool_add_ons: Dict = None, username_configuration: Dict = None, account_recovery_setting: Dict = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a new Amazon Cognito user pool and sets the password policy for the pool.  This action might generate an
    SMS text message. Starting June 1, 2021, U.S. telecom carriers require that you register an origination phone
    number before you can send SMS messages to U.S. phone numbers. If you use SMS text messages in Amazon Cognito,
    you must register a phone number with Amazon Pinpoint. Cognito will use the the registered number automatically.
    Otherwise, Cognito users that must receive SMS messages might be unable to sign up, activate their accounts, or
    sign in. If you have never used SMS text messages with Amazon Cognito or any other Amazon Web Service, Amazon
    SNS might place your account in SMS sandbox. In  sandbox mode , youâ€™ll have limitations, such as sending
    messages to only verified phone numbers. After testing in the sandbox environment, you can move out of the SMS
    sandbox and into production. For more information, see  SMS message settings for Cognito User Pools in the
    Amazon Cognito Developer Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        pool_name(Text): A string used to name the user pool.
        policies(Dict, optional): The policies associated with the new user pool. Defaults to None.
        lambda_config(Dict, optional): The Lambda trigger configuration information for the new user pool.  In a push model, event
            sources (such as Amazon S3 and custom applications) need permission to invoke a function. So you
            will need to make an extra call to add permission for these event sources to invoke your Lambda
            function.  For more information on using the Lambda API to add permission, see  AddPermission .
            For adding permission using the CLI, see  add-permission . Defaults to None.
        auto_verified_attributes(List, optional): The attributes to be auto-verified. Possible values: email, phone_number. Defaults to None.
        alias_attributes(List, optional): Attributes supported as an alias for this user pool. Possible values: phone_number, email, or
            preferred_username. Defaults to None.
        username_attributes(List, optional): Specifies whether email addresses or phone numbers can be specified as usernames when a user
            signs up. Defaults to None.
        sms_verification_message(Text, optional): A string representing the SMS verification message. Defaults to None.
        email_verification_message(Text, optional): A string representing the email verification message. EmailVerificationMessage is allowed only
            if EmailSendingAccount is DEVELOPER. Defaults to None.
        email_verification_subject(Text, optional): A string representing the email verification subject. EmailVerificationSubject is allowed only
            if EmailSendingAccount is DEVELOPER. Defaults to None.
        verification_message_template(Dict, optional): The template for the verification message that the user sees when the app requests permission to
            access the user's information. Defaults to None.
        sms_authentication_message(Text, optional): A string representing the SMS authentication message. Defaults to None.
        mfa_configuration(Text, optional): Specifies MFA configuration details. Defaults to None.
        device_configuration(Dict, optional): The device configuration. Defaults to None.
        email_configuration(Dict, optional): The email configuration. Defaults to None.
        sms_configuration(Dict, optional): The SMS configuration. Defaults to None.
        user_pool_tags(Dict, optional): The tag keys and values to assign to the user pool. A tag is a label that you can use to
            categorize and manage user pools in different ways, such as by purpose, owner, environment, or
            other criteria. Defaults to None.
        admin_create_user_config(Dict, optional): The configuration for AdminCreateUser requests. Defaults to None.
        schema(List, optional): An array of schema attributes for the new user pool. These attributes can be standard or custom
            attributes. Defaults to None.
        user_pool_add_ons(Dict, optional): Used to enable advanced security risk detection. Set the key AdvancedSecurityMode to the value
            "AUDIT". Defaults to None.
        username_configuration(Dict, optional): You can choose to set case sensitivity on the username input for the selected sign-in option.
            For example, when this is set to False, users will be able to sign in using either "username" or
            "Username". This configuration is immutable once it has been set. For more information, see
            UsernameConfigurationType. Defaults to None.
        account_recovery_setting(Dict, optional): Use this setting to define which verified available method a user can use to recover their
            password when they call ForgotPassword. It allows you to define a preferred method when a user
            has more than one method available. With this setting, SMS does not qualify for a valid password
            recovery mechanism if the user also has SMS MFA enabled. In the absence of this setting, Cognito
            uses the legacy behavior to determine the recovery method where SMS is preferred over email. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.cognito_idp.user_pool.present:
                - name: value
                - pool_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.cognito_idp.user_pool.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.cognito_idp.describe_user_pool(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.cognito_idp.create_user_pool(
                ctx,
                
                
                **{"PoolName": pool_name, "Policies": policies, "LambdaConfig": lambda_config, "AutoVerifiedAttributes": auto_verified_attributes, "AliasAttributes": alias_attributes, "UsernameAttributes": username_attributes, "SmsVerificationMessage": sms_verification_message, "EmailVerificationMessage": email_verification_message, "EmailVerificationSubject": email_verification_subject, "VerificationMessageTemplate": verification_message_template, "SmsAuthenticationMessage": sms_authentication_message, "MfaConfiguration": mfa_configuration, "DeviceConfiguration": device_configuration, "EmailConfiguration": email_configuration, "SmsConfiguration": sms_configuration, "UserPoolTags": user_pool_tags, "AdminCreateUserConfig": admin_create_user_config, "Schema": schema, "UserPoolAddOns": user_pool_add_ons, "UsernameConfiguration": username_configuration, "AccountRecoverySetting": account_recovery_setting}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.cognito_idp.describe_user_pool(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, user_pool_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified Amazon Cognito user pool.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        user_pool_id(Text): The user pool ID for the user pool you want to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.cognito_idp.user_pool.absent:
                - name: value
                - user_pool_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.cognito_idp.user_pool.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.cognito_idp.describe_user_pool(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.cognito_idp.delete_user_pool(
                ctx,
                
                
                **{"UserPoolId": user_pool_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.cognito_idp.describe_user_pool(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

