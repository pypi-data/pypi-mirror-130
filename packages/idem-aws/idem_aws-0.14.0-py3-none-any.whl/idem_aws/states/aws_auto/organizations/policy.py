"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.organizations.attach_policy
hub.exec.boto3.client.organizations.create_policy
hub.exec.boto3.client.organizations.delete_policy
hub.exec.boto3.client.organizations.describe_policy
hub.exec.boto3.client.organizations.detach_policy
hub.exec.boto3.client.organizations.list_policies
hub.exec.boto3.client.organizations.update_policy
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, content: Text, description: Text, type_: Text, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a policy of a specified type that you can attach to a root, an organizational unit (OU), or an
    individual AWS account. For more information about policies and their use, see Managing Organization Policies.
    If the request includes tags, then the requester must have the organizations:TagResource permission. This
    operation can be called only from the organization's management account.

    Args:
        name(Text): The friendly name to assign to the policy. The regex pattern that is used to validate this
            parameter is a string of any of the characters in the ASCII character range.
        content(Text): The policy text content to add to the new policy. The text that you supply must adhere to the
            rules of the policy type you specify in the Type parameter.
        description(Text): An optional description to assign to the policy.
        type_(Text): The type of policy to create. You can specify one of the following values:
            AISERVICES_OPT_OUT_POLICY     BACKUP_POLICY     SERVICE_CONTROL_POLICY     TAG_POLICY.
        tags(List, optional): A list of tags that you want to attach to the newly created policy. For each tag in the list,
            you must specify both a tag key and a value. You can set the value to an empty string, but you
            can't set it to null. For more information about tagging, see Tagging AWS Organizations
            resources in the AWS Organizations User Guide.  If any one of the tags is invalid or if you
            exceed the allowed number of tags for a policy, then the entire request fails and the policy is
            not created. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.organizations.policy.present:
                - name: value
                - content: value
                - description: value
                - type_: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.organizations.policy.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.organizations.describe_policy(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.organizations.create_policy(
                ctx,
                
                
                **{"Name": name, "Content": content, "Description": description, "Type": type_, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.organizations.describe_policy(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, policy_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified policy from your organization. Before you perform this operation, you must first detach
    the policy from all organizational units (OUs), roots, and accounts. This operation can be called only from the
    organization's management account.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        policy_id(Text): The unique identifier (ID) of the policy that you want to delete. You can get the ID from the
            ListPolicies or ListPoliciesForTarget operations. The regex pattern for a policy ID string
            requires "p-" followed by from 8 to 128 lowercase or uppercase letters, digits, or the
            underscore character (_).

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.organizations.policy.absent:
                - name: value
                - policy_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.organizations.policy.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.organizations.describe_policy(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.organizations.delete_policy(
                ctx,
                
                
                **{"PolicyId": policy_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.organizations.describe_policy(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

