"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.iam.attach_user_policy
hub.exec.boto3.client.iam.delete_user_policy
hub.exec.boto3.client.iam.detach_user_policy
hub.exec.boto3.client.iam.get_user_policy
hub.exec.boto3.client.iam.list_user_policies
hub.exec.boto3.client.iam.put_user_policy
resource = hub.tool.boto3.resource.create(ctx, "iam", "UserPolicy", name)
hub.tool.boto3.resource.exec(resource, delete, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, put, *args, **kwargs)
"""



import copy
from typing import *
import dict_tools.differ as differ

async def present(hub, ctx, name: Text, user_name: Text, policy_name: Text, policy_document: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Adds or updates an inline policy document that is embedded in the specified IAM user. An IAM user can also have
    a managed policy attached to it. To attach a managed policy to a user, use AttachUserPolicy. To create a new
    managed policy, use CreatePolicy. For information about policies, see Managed policies and inline policies in
    the IAM User Guide. For information about the maximum number of inline policies that you can embed in a user,
    see IAM and STS quotas in the IAM User Guide.  Because policy documents can be large, you should use POST rather
    than GET when calling PutUserPolicy. For general information about using the Query API with IAM, see Making
    query requests in the IAM User Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        user_name(Text): The name of the user to associate the policy with. This parameter allows (through its regex
            pattern) a string of characters consisting of upper and lowercase alphanumeric characters with
            no spaces. You can also include any of the following characters: _+=,.@-.
        policy_name(Text): The name of the policy document. This parameter allows (through its regex pattern) a string of
            characters consisting of upper and lowercase alphanumeric characters with no spaces. You can
            also include any of the following characters: _+=,.@-.
        policy_document(Text): The policy document. You must provide policies in JSON format in IAM. However, for
            CloudFormation templates formatted in YAML, you can provide the policy in JSON or YAML format.
            CloudFormation always converts a YAML policy to JSON format before submitting it to IAM. The
            regex pattern used to validate this parameter is a string of characters consisting of the
            following:   Any printable ASCII character ranging from the space character (\u0020) through the
            end of the ASCII character range   The printable characters in the Basic Latin and Latin-1
            Supplement character set (through \u00FF)   The special characters tab (\u0009), line feed
            (\u000A), and carriage return (\u000D).

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.iam.user_policy.present:
                - name: value
                - user_name: value
                - policy_name: value
                - policy_document: value
    '''

    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.iam.user_policy.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "iam", "UserPolicy", name)
    before = await hub.tool.boto3.resource.describe(resource)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.iam.put_user_policy(
                ctx,
                
                
                **{"UserName": user_name, "PolicyName": policy_name, "PolicyDocument": policy_document}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result



async def absent(hub, ctx, name: Text, user_name: Text, policy_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified inline policy that is embedded in the specified IAM user. A user can also have managed
    policies attached to it. To detach a managed policy from a user, use DetachUserPolicy. For more information
    about policies, refer to Managed policies and inline policies in the IAM User Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        user_name(Text): The name (friendly name, not ARN) identifying the user that the policy is embedded in. This
            parameter allows (through its regex pattern) a string of characters consisting of upper and
            lowercase alphanumeric characters with no spaces. You can also include any of the following
            characters: _+=,.@-.
        policy_name(Text): The name identifying the policy document to delete. This parameter allows (through its regex
            pattern) a string of characters consisting of upper and lowercase alphanumeric characters with
            no spaces. You can also include any of the following characters: _+=,.@-.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.iam.user_policy.absent:
                - name: value
                - user_name: value
                - policy_name: value
    '''

    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.iam.user_policy.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "iam", "UserPolicy", name)

    before = await hub.tool.boto3.resource.describe(resource)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.iam.delete_user_policy(
                ctx,
                
                
                **{"UserName": user_name, "PolicyName": policy_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result



async def describe(hub, ctx)  -> Dict[str, Dict[str, Any]]:
    r'''
    **Autogenerated function**

    Describe the resource in a way that can be recreated/managed with the corresponding "present" function

    
    Lists the names of the inline policies embedded in the specified IAM user. An IAM user can also have managed
    policies attached to it. To list the managed policies that are attached to a user, use ListAttachedUserPolicies.
    For more information about policies, see Managed policies and inline policies in the IAM User Guide. You can
    paginate the results using the MaxItems and Marker parameters. If there are no inline policies embedded with the
    specified user, the operation returns an empty list.


    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: bash

            $ idem describe aws_auto.iam.user_policy
    '''

    
    result = {}

    ret = await hub.exec.boto3.client.iam.list_user_policies(ctx)
    if not ret["status"]:
        hub.log.debug(f"Could not describe user_policy {ret['comment']}")
        return result

    for user_policy in ret["ret"]["TODO"]:
        new_user_policy = [
                {"UserName": user_name, "Marker": marker, "MaxItems": max_items}
        ]
        result[user_policy["user_policyId"]] = {"aws_auto.iam.user_policy.present": new_user_policy}

        for i, data in enumerate(user_policy.get("", ())):
            sub_user_policy = copy.deepcopy(new_user_policy)

            # TODO check for subresouruces
            sub_user_policy.append({})
            sub_user_policy.append({"name": "TODOs"})
            result[f"TODOs-{i}"] = {"aws_auto.iam.user_policy.present": sub_user_policy}

    return result


