"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.iam.delete_server_certificate
hub.exec.boto3.client.iam.get_server_certificate
hub.exec.boto3.client.iam.list_server_certificates
hub.exec.boto3.client.iam.tag_server_certificate
hub.exec.boto3.client.iam.untag_server_certificate
hub.exec.boto3.client.iam.update_server_certificate
hub.exec.boto3.client.iam.upload_server_certificate
resource = hub.tool.boto3.resource.create(ctx, "iam", "ServerCertificate", name)
hub.tool.boto3.resource.exec(resource, delete, *args, **kwargs)
hub.tool.boto3.resource.exec(resource, update, *args, **kwargs)
"""



import copy
from typing import *
import dict_tools.differ as differ

async def present(hub, ctx, name: Text, server_certificate_name: Text, certificate_body: Text, private_key: Text, path: Text = None, certificate_chain: Text = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Uploads a server certificate entity for the account. The server certificate entity includes a public key
    certificate, a private key, and an optional certificate chain, which should all be PEM-encoded. We recommend
    that you use Certificate Manager to provision, manage, and deploy your server certificates. With ACM you can
    request a certificate, deploy it to Amazon Web Services resources, and let ACM handle certificate renewals for
    you. Certificates provided by ACM are free. For more information about using ACM, see the Certificate Manager
    User Guide. For more information about working with server certificates, see Working with server certificates in
    the IAM User Guide. This topic includes a list of Amazon Web Services services that can use the server
    certificates that you manage with IAM. For information about the number of server certificates you can upload,
    see IAM and STS quotas in the IAM User Guide.  Because the body of the public key certificate, private key, and
    the certificate chain can be large, you should use POST rather than GET when calling UploadServerCertificate.
    For information about setting up signatures and authorization through the API, see Signing Amazon Web Services
    API requests in the Amazon Web Services General Reference. For general information about using the Query API
    with IAM, see Calling the API by making HTTP query requests in the IAM User Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        path(Text, optional): The path for the server certificate. For more information about paths, see IAM identifiers in
            the IAM User Guide. This parameter is optional. If it is not included, it defaults to a slash
            (/). This parameter allows (through its regex pattern) a string of characters consisting of
            either a forward slash (/) by itself or a string that must begin and end with forward slashes.
            In addition, it can contain any ASCII character from the ! (\u0021) through the DEL character
            (\u007F), including most punctuation characters, digits, and upper and lowercased letters.   If
            you are uploading a server certificate specifically for use with Amazon CloudFront
            distributions, you must specify a path using the path parameter. The path must begin with
            /cloudfront and must include a trailing slash (for example, /cloudfront/test/). Defaults to None.
        server_certificate_name(Text): The name for the server certificate. Do not include the path in this value. The name of the
            certificate cannot contain any spaces. This parameter allows (through its regex pattern) a
            string of characters consisting of upper and lowercase alphanumeric characters with no spaces.
            You can also include any of the following characters: _+=,.@-.
        certificate_body(Text): The contents of the public key certificate in PEM-encoded format. The regex pattern used to
            validate this parameter is a string of characters consisting of the following:   Any printable
            ASCII character ranging from the space character (\u0020) through the end of the ASCII character
            range   The printable characters in the Basic Latin and Latin-1 Supplement character set
            (through \u00FF)   The special characters tab (\u0009), line feed (\u000A), and carriage return
            (\u000D).
        private_key(Text): The contents of the private key in PEM-encoded format. The regex pattern used to validate this
            parameter is a string of characters consisting of the following:   Any printable ASCII character
            ranging from the space character (\u0020) through the end of the ASCII character range   The
            printable characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)
            The special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D).
        certificate_chain(Text, optional): The contents of the certificate chain. This is typically a concatenation of the PEM-encoded
            public key certificates of the chain. The regex pattern used to validate this parameter is a
            string of characters consisting of the following:   Any printable ASCII character ranging from
            the space character (\u0020) through the end of the ASCII character range   The printable
            characters in the Basic Latin and Latin-1 Supplement character set (through \u00FF)   The
            special characters tab (\u0009), line feed (\u000A), and carriage return (\u000D). Defaults to None.
        tags(List, optional): A list of tags that you want to attach to the new IAM server certificate resource. Each tag
            consists of a key name and an associated value. For more information about tagging, see Tagging
            IAM resources in the IAM User Guide.  If any one of the tags is invalid or if you exceed the
            allowed maximum number of tags, then the entire request fails and the resource is not created. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.iam.server_certificate.present:
                - name: value
                - server_certificate_name: value
                - certificate_body: value
                - private_key: value
    '''

    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.iam.server_certificate.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "iam", "ServerCertificate", name)
    before = await hub.tool.boto3.resource.describe(resource)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.iam.upload_server_certificate(
                ctx,
                
                
                **{"Path": path, "ServerCertificateName": server_certificate_name, "CertificateBody": certificate_body, "PrivateKey": private_key, "CertificateChain": certificate_chain, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result



async def absent(hub, ctx, name: Text, server_certificate_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified server certificate. For more information about working with server certificates, see
    Working with server certificates in the IAM User Guide. This topic also includes a list of Amazon Web Services
    services that can use the server certificates that you manage with IAM.   If you are using a server certificate
    with Elastic Load Balancing, deleting the certificate could have implications for your application. If Elastic
    Load Balancing doesn't detect the deletion of bound certificates, it may continue to use the certificates. This
    could cause Elastic Load Balancing to stop accepting traffic. We recommend that you remove the reference to the
    certificate from Elastic Load Balancing before using this command to delete the certificate. For more
    information, see DeleteLoadBalancerListeners in the Elastic Load Balancing API Reference.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        server_certificate_name(Text): The name of the server certificate you want to delete. This parameter allows (through its regex
            pattern) a string of characters consisting of upper and lowercase alphanumeric characters with
            no spaces. You can also include any of the following characters: _+=,.@-.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.iam.server_certificate.absent:
                - name: value
                - server_certificate_name: value
    '''

    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.iam.server_certificate.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    resource = hub.tool.boto3.resource.create(ctx, "iam", "ServerCertificate", name)

    before = await hub.tool.boto3.resource.describe(resource)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.iam.delete_server_certificate(
                ctx,
                
                
                **{"ServerCertificateName": server_certificate_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.tool.boto3.resource.describe(resource)
    result["changes"] = differ.deep_diff(before, after)
    return result



async def describe(hub, ctx)  -> Dict[str, Dict[str, Any]]:
    r'''
    **Autogenerated function**

    Describe the resource in a way that can be recreated/managed with the corresponding "present" function

    
    Lists the server certificates stored in IAM that have the specified path prefix. If none exist, the operation
    returns an empty list.  You can paginate the results using the MaxItems and Marker parameters. For more
    information about working with server certificates, see Working with server certificates in the IAM User Guide.
    This topic also includes a list of Amazon Web Services services that can use the server certificates that you
    manage with IAM.  IAM resource-listing operations return a subset of the available attributes for the resource.
    For example, this operation does not return tags, even though they are an attribute of the returned object. To
    view all of the information for a servercertificate, see GetServerCertificate.


    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: bash

            $ idem describe aws_auto.iam.server_certificate
    '''

    
    result = {}

    ret = await hub.exec.boto3.client.iam.list_server_certificates(ctx)
    if not ret["status"]:
        hub.log.debug(f"Could not describe server_certificate {ret['comment']}")
        return result

    for server_certificate in ret["ret"]["TODO"]:
        new_server_certificate = [
                {"PathPrefix": path_prefix, "Marker": marker, "MaxItems": max_items}
        ]
        result[server_certificate["server_certificateId"]] = {"aws_auto.iam.server_certificate.present": new_server_certificate}

        for i, data in enumerate(server_certificate.get("", ())):
            sub_server_certificate = copy.deepcopy(new_server_certificate)

            # TODO check for subresouruces
            sub_server_certificate.append({})
            sub_server_certificate.append({"name": "TODOs"})
            result[f"TODOs-{i}"] = {"aws_auto.iam.server_certificate.present": sub_server_certificate}

    return result


