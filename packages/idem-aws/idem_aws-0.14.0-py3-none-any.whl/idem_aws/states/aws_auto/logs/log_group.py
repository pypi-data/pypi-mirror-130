"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.logs.create_log_group
hub.exec.boto3.client.logs.delete_log_group
hub.exec.boto3.client.logs.describe_log_groups
hub.exec.boto3.client.logs.tag_log_group
hub.exec.boto3.client.logs.untag_log_group
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, log_group_name: Text, kms_key_id: Text = None, tags: Dict = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a log group with the specified name. You can create up to 20,000 log groups per account. You must use
    the following guidelines when naming a log group:   Log group names must be unique within a region for an Amazon
    Web Services account.   Log group names can be between 1 and 512 characters long.   Log group names consist of
    the following characters: a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen), '/' (forward slash), '.' (period), and
    '#' (number sign)   When you create a log group, by default the log events in the log group never expire. To set
    a retention policy so that events expire and are deleted after a specified time, use PutRetentionPolicy. If you
    associate a Key Management Service customer master key (CMK) with the log group, ingested data is encrypted
    using the CMK. This association is stored as long as the data encrypted with the CMK is still within CloudWatch
    Logs. This enables CloudWatch Logs to decrypt this data whenever it is requested. If you attempt to associate a
    CMK with the log group but the CMK does not exist or the CMK is disabled, you receive an
    InvalidParameterException error.   CloudWatch Logs supports only symmetric CMKs. Do not associate an asymmetric
    CMK with your log group. For more information, see Using Symmetric and Asymmetric Keys.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        log_group_name(Text): The name of the log group.
        kms_key_id(Text, optional): The Amazon Resource Name (ARN) of the CMK to use when encrypting log data. For more information,
            see Amazon Resource Names - Key Management Service. Defaults to None.
        tags(Dict, optional): The key-value pairs to use for the tags. CloudWatch Logs doesnâ€™t support IAM policies that
            prevent users from assigning specified tags to log groups using the aws:Resource/key-name  or
            aws:TagKeys condition keys. For more information about using tags to control access, see
            Controlling access to Amazon Web Services resources using tags. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.logs.log_group.present:
                - name: value
                - log_group_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.logs.log_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.logs.describe_log_groups(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.logs.create_log_group(
                ctx,
                
                
                **{"logGroupName": log_group_name, "kmsKeyId": kms_key_id, "tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.logs.describe_log_groups(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, log_group_name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified log group and permanently deletes all the archived log events associated with the log
    group.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        log_group_name(Text): The name of the log group.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.logs.log_group.absent:
                - name: value
                - log_group_name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.logs.log_group.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.logs.describe_log_groups(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.logs.delete_log_group(
                ctx,
                
                
                **{"logGroupName": log_group_name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.logs.describe_log_groups(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

