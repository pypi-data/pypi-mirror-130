"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.efs.create_mount_target
hub.exec.boto3.client.efs.delete_mount_target
hub.exec.boto3.client.efs.describe_mount_targets
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, file_system_id: Text, subnet_id: Text, ip_address: Text = None, security_groups: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a mount target for a file system. You can then mount the file system on EC2 instances by using the mount
    target. You can create one mount target in each Availability Zone in your VPC. All EC2 instances in a VPC within
    a given Availability Zone share a single mount target for a given file system. If you have multiple subnets in
    an Availability Zone, you create a mount target in one of the subnets. EC2 instances do not need to be in the
    same subnet as the mount target in order to access their file system. You can create only one mount target for
    an EFS file system using One Zone storage classes. You must create that mount target in the same Availability
    Zone in which the file system is located. Use the AvailabilityZoneName and AvailabiltyZoneId properties in the
    DescribeFileSystems response object to get this information. Use the subnetId associated with the file system's
    Availability Zone when creating the mount target. For more information, see Amazon EFS: How it Works.  To create
    a mount target for a file system, the file system's lifecycle state must be available. For more information, see
    DescribeFileSystems. In the request, provide the following:   The file system ID for which you are creating the
    mount target.   A subnet ID, which determines the following:   The VPC in which Amazon EFS creates the mount
    target   The Availability Zone in which Amazon EFS creates the mount target   The IP address range from which
    Amazon EFS selects the IP address of the mount target (if you don't specify an IP address in the request)
    After creating the mount target, Amazon EFS returns a response that includes, a MountTargetId and an IpAddress.
    You use this IP address when mounting the file system in an EC2 instance. You can also use the mount target's
    DNS name when mounting the file system. The EC2 instance on which you mount the file system by using the mount
    target can resolve the mount target's DNS name to its IP address. For more information, see How it Works:
    Implementation Overview.  Note that you can create mount targets for a file system in only one VPC, and there
    can be only one mount target per Availability Zone. That is, if the file system already has one or more mount
    targets created for it, the subnet specified in the request to add another mount target must meet the following
    requirements:   Must belong to the same VPC as the subnets of the existing mount targets   Must not be in the
    same Availability Zone as any of the subnets of the existing mount targets   If the request satisfies the
    requirements, Amazon EFS does the following:   Creates a new mount target in the specified subnet.   Also
    creates a new network interface in the subnet as follows:   If the request provides an IpAddress, Amazon EFS
    assigns that IP address to the network interface. Otherwise, Amazon EFS assigns a free address in the subnet (in
    the same way that the Amazon EC2 CreateNetworkInterface call does when a request does not specify a primary
    private IP address).   If the request provides SecurityGroups, this network interface is associated with those
    security groups. Otherwise, it belongs to the default security group for the subnet's VPC.   Assigns the
    description Mount target fsmt-id for file system fs-id  where  fsmt-id  is the mount target ID, and  fs-id  is
    the FileSystemId.   Sets the requesterManaged property of the network interface to true, and the requesterId
    value to EFS.   Each Amazon EFS mount target has one corresponding requester-managed EC2 network interface.
    After the network interface is created, Amazon EFS sets the NetworkInterfaceId field in the mount target's
    description to the network interface ID, and the IpAddress field to its address. If network interface creation
    fails, the entire CreateMountTarget operation fails.    The CreateMountTarget call returns only after creating
    the network interface, but while the mount target state is still creating, you can check the mount target
    creation status by calling the DescribeMountTargets operation, which among other things returns the mount target
    state.  We recommend that you create a mount target in each of the Availability Zones. There are cost
    considerations for using a file system in an Availability Zone through a mount target created in another
    Availability Zone. For more information, see Amazon EFS. In addition, by always using a mount target local to
    the instance's Availability Zone, you eliminate a partial failure scenario. If the Availability Zone in which
    your mount target is created goes down, then you can't access your file system through that mount target.  This
    operation requires permissions for the following action on the file system:
    elasticfilesystem:CreateMountTarget    This operation also requires permissions for the following Amazon EC2
    actions:    ec2:DescribeSubnets     ec2:DescribeNetworkInterfaces     ec2:CreateNetworkInterface

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        file_system_id(Text): The ID of the file system for which to create the mount target.
        subnet_id(Text): The ID of the subnet to add the mount target in. For file systems that use One Zone storage
            classes, use the subnet that is associated with the file system's Availability Zone.
        ip_address(Text, optional): Valid IPv4 address within the address range of the specified subnet. Defaults to None.
        security_groups(List, optional): Up to five VPC security group IDs, of the form sg-xxxxxxxx. These must be for the same VPC as
            subnet specified. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.efs.mount_target.present:
                - name: value
                - file_system_id: value
                - subnet_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.efs.mount_target.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.efs.describe_mount_targets(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.efs.create_mount_target(
                ctx,
                
                
                **{"FileSystemId": file_system_id, "SubnetId": subnet_id, "IpAddress": ip_address, "SecurityGroups": security_groups}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.efs.describe_mount_targets(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, mount_target_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified mount target. This operation forcibly breaks any mounts of the file system by using the
    mount target that is being deleted, which might disrupt instances or applications using those mounts. To avoid
    applications getting cut off abruptly, you might consider unmounting any mounts of the mount target, if
    feasible. The operation also deletes the associated network interface. Uncommitted writes might be lost, but
    breaking a mount target using this operation does not corrupt the file system itself. The file system you
    created remains. You can mount an EC2 instance in your VPC by using another mount target. This operation
    requires permissions for the following action on the file system:    elasticfilesystem:DeleteMountTarget     The
    DeleteMountTarget call returns while the mount target state is still deleting. You can check the mount target
    deletion by calling the DescribeMountTargets operation, which returns a list of mount target descriptions for
    the given file system.   The operation also requires permissions for the following Amazon EC2 action on the
    mount target's network interface:    ec2:DeleteNetworkInterface

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        mount_target_id(Text): The ID of the mount target to delete (String).

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.efs.mount_target.absent:
                - name: value
                - mount_target_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.efs.mount_target.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.efs.describe_mount_targets(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.efs.delete_mount_target(
                ctx,
                
                
                **{"MountTargetId": mount_target_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.efs.describe_mount_targets(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

