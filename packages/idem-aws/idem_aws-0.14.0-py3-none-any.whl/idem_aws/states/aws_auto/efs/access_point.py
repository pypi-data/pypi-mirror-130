"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.efs.create_access_point
hub.exec.boto3.client.efs.delete_access_point
hub.exec.boto3.client.efs.describe_access_points
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, file_system_id: Text, tags: List = None, posix_user: Dict = None, root_directory: Dict = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates an EFS access point. An access point is an application-specific view into an EFS file system that
    applies an operating system user and group, and a file system path, to any file system request made through the
    access point. The operating system user and group override any identity information provided by the NFS client.
    The file system path is exposed as the access point's root directory. Applications using the access point can
    only access data in its own directory and below. To learn more, see Mounting a file system using EFS access
    points. This operation requires permissions for the elasticfilesystem:CreateAccessPoint action.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        tags(List, optional): Creates tags associated with the access point. Each tag is a key-value pair. Defaults to None.
        file_system_id(Text): The ID of the EFS file system that the access point provides access to.
        posix_user(Dict, optional): The operating system user and group applied to all file system requests made using the access
            point. Defaults to None.
        root_directory(Dict, optional): Specifies the directory on the Amazon EFS file system that the access point exposes as the root
            directory of your file system to NFS clients using the access point. The clients using the
            access point can only access the root directory and below. If the RootDirectory > Path specified
            does not exist, EFS creates it and applies the CreationInfo settings when a client connects to
            an access point. When specifying a RootDirectory, you need to provide the Path, and the
            CreationInfo. Amazon EFS creates a root directory only if you have provided the CreationInfo:
            OwnUid, OwnGID, and permissions for the directory. If you do not provide this information,
            Amazon EFS does not create the root directory. If the root directory does not exist, attempts to
            mount using the access point will fail. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.efs.access_point.present:
                - name: value
                - file_system_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.efs.access_point.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.efs.describe_access_points(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.efs.create_access_point(
                ctx,
                
                ClientToken=name,
                **{"Tags": tags, "FileSystemId": file_system_id, "PosixUser": posix_user, "RootDirectory": root_directory}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.efs.describe_access_points(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, access_point_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes the specified access point. After deletion is complete, new clients can no longer connect to the access
    points. Clients connected to the access point at the time of deletion will continue to function until they
    terminate their connection. This operation requires permissions for the elasticfilesystem:DeleteAccessPoint
    action.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        access_point_id(Text): The ID of the access point that you want to delete.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.efs.access_point.absent:
                - name: value
                - access_point_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.efs.access_point.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.efs.describe_access_points(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.efs.delete_access_point(
                ctx,
                
                
                **{"AccessPointId": access_point_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.efs.describe_access_points(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

