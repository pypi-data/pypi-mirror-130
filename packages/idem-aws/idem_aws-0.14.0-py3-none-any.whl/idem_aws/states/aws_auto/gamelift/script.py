"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.gamelift.create_script
hub.exec.boto3.client.gamelift.delete_script
hub.exec.boto3.client.gamelift.describe_script
hub.exec.boto3.client.gamelift.list_scripts
hub.exec.boto3.client.gamelift.update_script
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text = None, version: Text = None, storage_location: Dict = None, zip_file: ByteString = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a new script record for your Realtime Servers script. Realtime scripts are JavaScript that provide
    configuration settings and optional custom game logic for your game. The script is deployed when you create a
    Realtime Servers fleet to host your game sessions. Script logic is executed during an active game session.  To
    create a new script record, specify a script name and provide the script file(s). The script files and all
    dependencies must be zipped into a single file. You can pull the zip file from either of these locations:    A
    locally available directory. Use the ZipFile parameter for this option.   An Amazon Simple Storage Service
    (Amazon S3) bucket under your AWS account. Use the StorageLocation parameter for this option. You'll need to
    have an Identity Access Management (IAM) role that allows the Amazon GameLift service to access your S3 bucket.
    If the call is successful, a new script record is created with a unique script ID. If the script file is
    provided as a local file, the file is uploaded to an Amazon GameLift-owned S3 bucket and the script record's
    storage location reflects this location. If the script file is provided as an S3 bucket, Amazon GameLift
    accesses the file at this storage location as needed for deployment.  Learn more   Amazon GameLift Realtime
    Servers   Set Up a Role for Amazon GameLift Access   Related actions   CreateScript | ListScripts |
    DescribeScript | UpdateScript | DeleteScript | All APIs by task

    Args:
        name(Text, optional): A descriptive label that is associated with a script. Script names do not need to be unique. You
            can use UpdateScript to change this value later. Defaults to None.
        version(Text, optional): Version information that is associated with a build or script. Version strings do not need to be
            unique. You can use UpdateScript to change this value later. Defaults to None.
        storage_location(Dict, optional): The location of the Amazon S3 bucket where a zipped file containing your Realtime scripts is
            stored. The storage location must specify the Amazon S3 bucket name, the zip file name (the
            "key"), and a role ARN that allows Amazon GameLift to access the Amazon S3 storage location. The
            S3 bucket must be in the same Region where you want to create a new script. By default, Amazon
            GameLift uploads the latest version of the zip file; if you have S3 object versioning turned on,
            you can use the ObjectVersion parameter to specify an earlier version. Defaults to None.
        zip_file(ByteString, optional): A data object containing your Realtime scripts and dependencies as a zip file. The zip file can
            have one or multiple files. Maximum size of a zip file is 5 MB. When using the AWS CLI tool to
            create a script, this parameter is set to the zip file name. It must be prepended with the
            string "fileb://" to indicate that the file data is a binary object. For example: --zip-file
            fileb://myRealtimeScript.zip. Defaults to None.
        tags(List, optional): A list of labels to assign to the new script resource. Tags are developer-defined key-value
            pairs. Tagging AWS resources are useful for resource management, access management and cost
            allocation. For more information, see  Tagging AWS Resources in the AWS General Reference. Once
            the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to add,
            remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General
            Reference for actual tagging limits. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.gamelift.script.present:
                - 
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.gamelift.script.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.gamelift.describe_script(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.gamelift.create_script(
                ctx,
                
                
                **{"Name": name, "Version": version, "StorageLocation": storage_location, "ZipFile": zip_file, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.gamelift.describe_script(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, script_id: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a Realtime script. This operation permanently deletes the script record. If script files were uploaded,
    they are also deleted (files stored in an S3 bucket are not deleted).  To delete a script, specify the script
    ID. Before deleting a script, be sure to terminate all fleets that are deployed with the script being deleted.
    Fleet instances periodically check for script updates, and if the script record no longer exists, the instance
    will go into an error state and be unable to host game sessions.  Learn more   Amazon GameLift Realtime Servers
    Related actions   CreateScript | ListScripts | DescribeScript | UpdateScript | DeleteScript | All APIs by task

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        script_id(Text): A unique identifier for the Realtime script to delete. You can use either the script ID or ARN
            value.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.gamelift.script.absent:
                - name: value
                - script_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.gamelift.script.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.gamelift.describe_script(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.gamelift.delete_script(
                ctx,
                
                
                **{"ScriptId": script_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.gamelift.describe_script(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

