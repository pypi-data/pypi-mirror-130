"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.gamelift.create_game_session_queue
hub.exec.boto3.client.gamelift.delete_game_session_queue
hub.exec.boto3.client.gamelift.describe_game_session_queues
hub.exec.boto3.client.gamelift.update_game_session_queue
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, timeout_in_seconds: int = None, player_latency_policies: List = None, destinations: List = None, filter_configuration: Dict = None, priority_configuration: Dict = None, custom_event_data: Text = None, notification_target: Text = None, tags: List = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a placement queue that processes requests for new game sessions. A queue uses FleetIQ algorithms to
    determine the best placement locations and find an available game server there, then prompts the game server
    process to start a new game session.  A game session queue is configured with a set of destinations (GameLift
    fleets or aliases), which determine the locations where the queue can place new game sessions. These
    destinations can span multiple fleet types (Spot and On-Demand), instance types, and AWS Regions. If the queue
    includes multi-location fleets, the queue is able to place game sessions in all of a fleet's remote locations.
    You can opt to filter out individual locations if needed. The queue configuration also determines how FleetIQ
    selects the best available placement for a new game session. Before searching for an available game server,
    FleetIQ first prioritizes the queue's destinations and locations, with the best placement locations on top. You
    can set up the queue to use the FleetIQ default prioritization or provide an alternate set of priorities. To
    create a new queue, provide a name, timeout value, and a list of destinations. Optionally, specify a sort
    configuration and/or a filter, and define a set of latency cap policies. You can also include the ARN for an
    Amazon Simple Notification Service (SNS) topic to receive notifications of game session placement activity.
    Notifications using SNS or CloudWatch events is the preferred way to track placement activity. If successful, a
    new GameSessionQueue object is returned with an assigned queue ARN. New game session requests, which are
    submitted to the queue with StartGameSessionPlacement or StartMatchmaking, reference a queue's name or ARN.
    Learn more    Design a game session queue    Create a game session queue   Related actions
    CreateGameSessionQueue | DescribeGameSessionQueues | UpdateGameSessionQueue | DeleteGameSessionQueue | All APIs
    by task

    Args:
        name(Text): A descriptive label that is associated with game session queue. Queue names must be unique
            within each Region.
        timeout_in_seconds(int, optional): The maximum time, in seconds, that a new game session placement request remains in the queue.
            When a request exceeds this time, the game session placement changes to a TIMED_OUT status. Defaults to None.
        player_latency_policies(List, optional): A set of policies that act as a sliding cap on player latency. FleetIQ works to deliver low
            latency for most players in a game session. These policies ensure that no individual player can
            be placed into a game with unreasonably high latency. Use multiple policies to gradually relax
            latency requirements a step at a time. Multiple policies are applied based on their maximum
            allowed latency, starting with the lowest value. Defaults to None.
        destinations(List, optional): A list of fleets and/or fleet aliases that can be used to fulfill game session placement
            requests in the queue. Destinations are identified by either a fleet ARN or a fleet alias ARN,
            and are listed in order of placement preference. Defaults to None.
        filter_configuration(Dict, optional): A list of locations where a queue is allowed to place new game sessions. Locations are specified
            in the form of AWS Region codes, such as us-west-2. If this parameter is not set, game sessions
            can be placed in any queue location. Defaults to None.
        priority_configuration(Dict, optional): Custom settings to use when prioritizing destinations and locations for game session placements.
            This configuration replaces the FleetIQ default prioritization process. Priority types that are
            not explicitly named will be automatically applied at the end of the prioritization process. Defaults to None.
        custom_event_data(Text, optional):  Information to be added to all events that are related to this game session queue. Defaults to None.
        notification_target(Text, optional): An SNS topic ARN that is set up to receive game session placement notifications. See  Setting up
            notifications for game session placement. Defaults to None.
        tags(List, optional): A list of labels to assign to the new game session queue resource. Tags are developer-defined
            key-value pairs. Tagging AWS resources are useful for resource management, access management and
            cost allocation. For more information, see  Tagging AWS Resources in the AWS General Reference.
            Once the resource is created, you can use TagResource, UntagResource, and ListTagsForResource to
            add, remove, and view tags. The maximum tag limit may be lower than stated. See the AWS General
            Reference for actual tagging limits. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.gamelift.game_session_queue.present:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.gamelift.game_session_queue.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.gamelift.describe_game_session_queues(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.gamelift.create_game_session_queue(
                ctx,
                
                
                **{"Name": name, "TimeoutInSeconds": timeout_in_seconds, "PlayerLatencyPolicies": player_latency_policies, "Destinations": destinations, "FilterConfiguration": filter_configuration, "PriorityConfiguration": priority_configuration, "CustomEventData": custom_event_data, "NotificationTarget": notification_target, "Tags": tags}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.gamelift.describe_game_session_queues(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a game session queue. Once a queue is successfully deleted, unfulfilled StartGameSessionPlacement
    requests that reference the queue will fail. To delete a queue, specify the queue name.  Learn more    Using
    Multi-Region Queues   Related actions   CreateGameSessionQueue | DescribeGameSessionQueues |
    UpdateGameSessionQueue | DeleteGameSessionQueue | All APIs by task

    Args:
        name(Text): A descriptive label that is associated with game session queue. Queue names must be unique
            within each Region. You can use either the queue ID or ARN value.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.gamelift.game_session_queue.absent:
                - name: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.gamelift.game_session_queue.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.gamelift.describe_game_session_queues(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.gamelift.delete_game_session_queue(
                ctx,
                
                
                **{"Name": name}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.gamelift.describe_game_session_queues(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

