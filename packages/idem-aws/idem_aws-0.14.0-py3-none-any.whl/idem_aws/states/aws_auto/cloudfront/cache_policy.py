"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.cloudfront.create_cache_policy
hub.exec.boto3.client.cloudfront.delete_cache_policy
hub.exec.boto3.client.cloudfront.get_cache_policy
hub.exec.boto3.client.cloudfront.list_cache_policies
hub.exec.boto3.client.cloudfront.update_cache_policy
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, cache_policy_config: Dict)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Creates a cache policy. After you create a cache policy, you can attach it to one or more cache behaviors. When
    it’s attached to a cache behavior, the cache policy determines the following:   The values that CloudFront
    includes in the cache key. These values can include HTTP headers, cookies, and URL query strings. CloudFront
    uses the cache key to find an object in its cache that it can return to the viewer.   The default, minimum, and
    maximum time to live (TTL) values that you want objects to stay in the CloudFront cache.   The headers, cookies,
    and query strings that are included in the cache key are automatically included in requests that CloudFront
    sends to the origin. CloudFront sends a request when it can’t find an object in its cache that matches the
    request’s cache key. If you want to send values to the origin but not include them in the cache key, use
    OriginRequestPolicy. For more information about cache policies, see Controlling the cache key in the Amazon
    CloudFront Developer Guide.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        cache_policy_config(Dict): A cache policy configuration.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.cloudfront.cache_policy.present:
                - name: value
                - cache_policy_config: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.cloudfront.cache_policy.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.cloudfront.get_cache_policy(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.cloudfront.create_cache_policy(
                ctx,
                
                
                **{"CachePolicyConfig": cache_policy_config}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.cloudfront.get_cache_policy(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, id_: Text, if_match: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a cache policy. You cannot delete a cache policy if it’s attached to a cache behavior. First update your
    distributions to remove the cache policy from all cache behaviors, then delete the cache policy. To delete a
    cache policy, you must provide the policy’s identifier and version. To get these values, you can use
    ListCachePolicies or GetCachePolicy.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        id_(Text): The unique identifier for the cache policy that you are deleting. To get the identifier, you can
            use ListCachePolicies.
        if_match(Text, optional): The version of the cache policy that you are deleting. The version is the cache policy’s ETag
            value, which you can get using ListCachePolicies, GetCachePolicy, or GetCachePolicyConfig. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.cloudfront.cache_policy.absent:
                - name: value
                - id_: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.cloudfront.cache_policy.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.cloudfront.get_cache_policy(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.cloudfront.delete_cache_policy(
                ctx,
                
                
                **{"Id": id_, "IfMatch": if_match}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.cloudfront.get_cache_policy(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

