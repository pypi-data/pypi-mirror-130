"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

hub.exec.boto3.client.kendra.delete_principal_mapping
hub.exec.boto3.client.kendra.describe_principal_mapping
hub.exec.boto3.client.kendra.put_principal_mapping
"""



from typing import *
import dict_tools.differ as differ
async def present(hub, ctx, name: Text, index_id: Text, group_id: Text, group_members: Dict, data_source_id: Text = None, ordering_id: int = None, role_arn: Text = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Maps users to their groups. You can also map sub groups to groups. For example, the group "Company Intellectual
    Property Teams" includes sub groups "Research" and "Engineering". These sub groups include their own list of
    users or people who work in these teams. Only users who work in research and engineering, and therefore belong
    in the intellectual property group, can see top-secret company documents in their search results.  You map users
    to their groups when you want to filter search results for different users based on their groupâ€™s access to
    documents. For more information on filtering search results for different users, see Filtering on user context.
    If more than five PUT actions for a group are currently processing, a validation exception is thrown.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        index_id(Text): The identifier of the index you want to map users to their groups.
        data_source_id(Text, optional): The identifier of the data source you want to map users to their groups. This is useful if a
            group is tied to multiple data sources, but you only want the group to access documents of a
            certain data source. For example, the groups "Research", "Engineering", and "Sales and
            Marketing" are all tied to the company's documents stored in the data sources Confluence and
            Salesforce. However, "Sales and Marketing" team only needs access to customer-related documents
            stored in Salesforce. Defaults to None.
        group_id(Text): The identifier of the group you want to map its users to.
        group_members(Dict): The list that contains your users or sub groups that belong the same group. For example, the
            group "Company" includes the user "CEO" and the sub groups "Research", "Engineering", and "Sales
            and Marketing". If you have more than 1000 users and/or sub groups for a single group, you need
            to provide the path to the S3 file that lists your users and sub groups for a group. Your sub
            groups can contain more than 1000 users, but the list of sub groups that belong to a group
            (and/or users) must be no more than 1000.
        ordering_id(int, optional): The timestamp identifier you specify to ensure Amazon Kendra does not override the latest PUT
            action with previous actions. The highest number ID, which is the ordering ID, is the latest
            action you want to process and apply on top of other actions with lower number IDs. This
            prevents previous actions with lower number IDs from possibly overriding the latest action. The
            ordering ID can be the UNIX time of the last update you made to a group members list. You would
            then provide this list when calling PutPrincipalMapping. This ensures your PUT action for that
            updated group with the latest members list doesn't get overwritten by earlier PUT actions for
            the same group which are yet to be processed. The default ordering ID is the current UNIX time
            in milliseconds that the action was received by Amazon Kendra. Defaults to None.
        role_arn(Text, optional): The Amazon Resource Name (ARN) of a role that has access to the S3 file that contains your list
            of users or sub groups that belong to a group. For more information, see IAM roles for Amazon
            Kendra. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_present:
              aws_auto.kendra.principal_mapping.present:
                - name: value
                - index_id: value
                - group_id: value
                - group_members: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.kendra.principal_mapping.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    
    before = await hub.exec.boto3.client.kendra.describe_principal_mapping(name)

    if before:
        result["comment"] = f"'{name}' already exists"
    else:
        try:
            ret = await hub.exec.boto3.client.kendra.put_principal_mapping(
                ctx,
                
                
                **{"IndexId": index_id, "DataSourceId": data_source_id, "GroupId": group_id, "GroupMembers": group_members, "OrderingId": ordering_id, "RoleArn": role_arn}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            ret["comment"] = f"Created '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    
    # TODO perform other modifications as needed here
    ...

    after = await hub.exec.boto3.client.kendra.describe_principal_mapping(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

async def absent(hub, ctx, name: Text, index_id: Text, group_id: Text, data_source_id: Text = None, ordering_id: int = None)  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    
    Deletes a group so that all users and sub groups that belong to the group can no longer access documents only
    available to that group. For example, after deleting the group "Summer Interns", all interns who belonged to
    that group no longer see intern-only documents in their search results. If you want to delete or replace users
    or sub groups of a group, you need to use the PutPrincipalMapping operation. For example, if a user in the group
    "Engineering" leaves the engineering team and another user takes their place, you provide an updated list of
    users or sub groups that belong to the "Engineering" group when calling PutPrincipalMapping. You can update your
    internal list of users or sub groups and input this list when calling PutPrincipalMapping.

    Args:
        name(Text): A name, ID, or JMES search path to identify the resource.
        index_id(Text): The identifier of the index you want to delete a group from.
        data_source_id(Text, optional): The identifier of the data source you want to delete a group from. This is useful if a group is
            tied to multiple data sources and you want to delete a group from accessing documents in a
            certain data source. For example, the groups "Research", "Engineering", and "Sales and
            Marketing" are all tied to the company's documents stored in the data sources Confluence and
            Salesforce. You want to delete "Research" and "Engineering" groups from Salesforce, so that
            these groups cannot access customer-related documents stored in Salesforce. Only "Sales and
            Marketing" should access documents in the Salesforce data source. Defaults to None.
        group_id(Text): The identifier of the group you want to delete.
        ordering_id(int, optional): The timestamp identifier you specify to ensure Amazon Kendra does not override the latest DELETE
            action with previous actions. The highest number ID, which is the ordering ID, is the latest
            action you want to process and apply on top of other actions with lower number IDs. This
            prevents previous actions with lower number IDs from possibly overriding the latest action. The
            ordering ID can be the UNIX time of the last update you made to a group members list. You would
            then provide this list when calling PutPrincipalMapping. This ensures your DELETE action for
            that updated group with the latest members list doesn't get overwritten by earlier DELETE
            actions for the same group which are yet to be processed. The default ordering ID is the current
            UNIX time in milliseconds that the action was received by Amazon Kendra. Defaults to None.

    Returns:
        Dict[str, Any]

    Examples:

        .. code-block:: sls

            resource_is_absent:
              aws_auto.kendra.principal_mapping.absent:
                - name: value
                - index_id: value
                - group_id: value
    '''
    
    result = dict(comment="", changes= None, name=name, result=True)
    ret = await hub.exec.boto3.client.kendra.principal_mapping.id(
        ctx,
        jmes_path=name
    )
    if ret["status"]:
        # name is now the first id that matched the JMES search path
        name = ret["ret"]
    

    

    before = await hub.exec.boto3.client.kendra.describe_principal_mapping(name)

    if not before:
        result["comment"] = f"'{name}' already absent"
    else:
        try:
            ret = await hub.exec.boto3.client.kendra.delete_principal_mapping(
                ctx,
                
                
                **{"IndexId": index_id, "DataSourceId": data_source_id, "GroupId": group_id, "OrderingId": ordering_id}
            )
            result["result"] = ret["status"]
            if not result["result"]:
                result["comment"] = ret["comment"]
                return result
            result["comment"] = f"Deleted '{name}'"
        except hub.tool.boto3.exception.ClientError as e:
            result["comment"] = f"{e.__class__.__name__}: {e}"

    

    after = await hub.exec.boto3.client.kendra.describe_principal_mapping(name)
    result["changes"] = differ.deep_diff(before, after)
    return result

