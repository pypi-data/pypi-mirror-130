# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['healpix_alchemy', 'healpix_alchemy.tests', 'healpix_alchemy.tests.benchmarks']

package_data = \
{'': ['*']}

install_requires = \
['astropy', 'astropy_healpix', 'mocpy>=0.10.0', 'sqlalchemy>=1.4']

setup_kwargs = {
    'name': 'healpix-alchemy',
    'version': '1.0.1',
    'description': 'SQLAlchemy extensions for HEALPix spatially indexed astronomy data',
    'long_description': "[![PyPI Status](https://img.shields.io/pypi/v/healpix-alchemy)](https://pypi.org/project/healpix-alchemy/)\n[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/skyportal/healpix-alchemy/build-and-test)](https://github.com/skyportal/healpix-alchemy/actions)\n[![codecov](https://codecov.io/gh/skyportal/healpix-alchemy/branch/main/graph/badge.svg?token=T34O35OM0V)](https://codecov.io/gh/skyportal/healpix-alchemy)\n\n# HEALPix Alchemy\n\nThe `healpix_alchemy` Python package is an extension for the [SQLAlchemy]\nobject relational mapper. It adds region and image arithmetic to [PostgreSQL]\n(version 14 and newer) databases. It accelerates queries between point clouds,\nregions, and images (sometimes known in the geospatial community as rasters) by\nstoring [multi-order] [HEALPix] indices in PostgreSQL's [range types].\n\nThe `healpix_alchemy` project is designed for astronomy applications,\nparticularly for cross-matching galaxy catalogs, observation footprints, and\nall-sky images like [gravitational-wave probability sky maps] or even dust\nmaps. However, it could be used in any context in which geometry is embedded on\na unit sphere.\n\n`healpix_alchemy` is lean and minimalist because it leverages several existing\nprojects: it consists of little more than a few lines of glue code to bind\ntogether [MOCPy], [SQLAlchemy], and PostgreSQL's [range types].\n\n`healpix_alchemy` serves a purpose similar to full-featured astronomy-focused\nspatial extensions like [Q3C], [H3C], and [pg_healpix], and geospatial\nextensions like [PgSphere] and [PostGIS]. What sets `healpix_alchemy` apart\nfrom these is that it is written in pure Python and requires no server-side\ndatabase extensions. Consequently, `healpix_alchemy` can be used with managed\nPostgreSQL databases in the cloud like [Amazon RDS] and [Google Cloud SQL].\n\n[2MASS Redshift Survey]: https://lweb.cfa.harvard.edu/~dfabricant/huchra/2mass/\n[Aladin]: https://aladin.u-strasbg.fr\n[Amazon RDS]: https://aws.amazon.com/rds/\n[astropy.coordinates.SkyCoord]: https://docs.astropy.org/en/stable/api/astropy.coordinates.SkyCoord.html#astropy.coordinates.SkyCoord\n[astropy.units.Quantity]: https://docs.astropy.org/en/stable/api/astropy.units.Quantity.html#astropy.units.Quantity\n[custom column types]: https://docs.sqlalchemy.org/en/14/core/custom_types.html\n[Google Cloud SQL]: https://cloud.google.com/sql\n[Górski et al. (2005)]: https://doi.org/10.1086/427976\n[gravitational-wave probability sky maps]: https://emfollow.docs.ligo.org/userguide/tutorial/skymaps.html\n[GW200115_042309]: https://doi.org/10.3847/2041-8213/ac082e\n[H3C]: http://cdsarc.u-strasbg.fr/h3c\n[HEALPix]: https://healpix.sourceforge.io\n[hierarchical progressive surveys (HiPS)]: https://www.ivoa.net/documents/HiPS/\n[ICRS]: https://docs.astropy.org/en/stable/api/astropy.coordinates.builtin_frames.ICRS.html#astropy.coordinates.builtin_frames.ICRS\n[ligo-segments]: https://lscsoft.docs.ligo.org/ligo-segments/\n[MOCPy documentation]: https://cds-astro.github.io/mocpy/\n[MOCPy]: https://github.com/tboch/mocpy\n[multi-order coverage (MOC)]: https://ivoa.net/documents/MOC/\n[multi-order]: https://doi.org/10.1051/0004-6361/201526549\n[official Poetry installation instructions]: https://python-poetry.org/docs/#installation\n[pg_healpix]: https://github.com/segasai/pg_healpix\n[PgSphere]: https://pgsphere.github.io\n[pip]: https://pip.pypa.io/\n[Poetry]: https://python-poetry.org/\n[PostGIS]: https://postgis.net\n[PostgreSQL]: https://www.postgresql.org\n[pyranges]: https://github.com/biocore-ntnu/pyranges\n[pytest]: https://pytest.org/\n[Q3C]: https://github.com/segasai/q3c\n[range types]: https://www.postgresql.org/docs/current/rangetypes.html\n[S200115j]: https://gracedb.ligo.org/superevents/S200115j/view/\n[Singer & Price (2015)]: https://doi.org/10.1103/PhysRevD.93.024013\n[SQLAlchemy bulk insertion]: https://docs.sqlalchemy.org/en/14/orm/persistence_techniques.html#bulk-operations\n[SQLAlchemy]: https://www.sqlalchemy.org\n[UNIQ]: https://healpix.sourceforge.io/doc/html/intro_Geometric_Algebraic_Propert.htm#SECTION420\n[Zwicky Transient Facility]: https://www.ztf.caltech.edu\n\n## Theory of operation\n\n### HEALPix basics\n\n[HEALPix] is a scheme for subdividing and indexing the unit sphere, originally\ndescribed by [Górski et al. (2005)]. Although it was originally designed for\ncosmic microwave background analysis, it has found many uses in astronomy,\nparticularly through [multi-order coverage (MOC)] maps and\n[hierarchical progressive surveys (HiPS)] used extensively in the [Aladin]\nastronomical information system. It is also used by LIGO and Virgo to store and\ncommunicate [gravitational-wave probability sky maps].\n\nHEALPix can be thought of as a tree. At the lowest resolution, level 0, HEALPix\nsubdivides the sphere into 12 equal-area base tiles, assigned integer indices\n0 through 11. At level 1, each of the 12 base tiles is subdivided into 4 tiles.\nEvery subsequent level divides each of the preceding level's tiles into 4 new\ntiles. At a given level, each of the base pixels has been divided into\n4<sup>_level_</sup> pixels (_nside_ = 2<sup>_level_</sup> pixels on each side).\nThus there are _npix_ = 12×4<sup>_level_</sup> pixels at a given resolution,\nassigned integer indices from 0 through (_npix_-1). This is called the NESTED\nindexing scheme. (There is also a RING indexing scheme in which the indices\nadvance from east to west and then from north to south.)\n\nA HEALPix tile, a node in the HEALPix tree, is fully addressed by three pieces\nof information: the indexing scheme (RING or NESTED), the resolution level\n(_level_ or equivalently _nside_), and the pixel index (_ipix_, an integer\nbetween 0 and _npix_-1).\n\nThe image below, reproduced from https://healpix.jpl.nasa.gov, illustrates the\nfirst 4 levels of refinement of a HEALPix grid.\n\n![The first four levels of HEALPix subdivision of the unit sphere](https://healpix.jpl.nasa.gov/images/healpixGridRefinement.jpg)\n\n### HEALPix interval sets\n\nA region on the sphere can be encoded by a collection of disjoint HEALPix\ntiles, potentially at a mix of different resolution levels. Typically, large\nlow-resolution tiles are used on the interior of the region, and small\nhigh-resolution tiles are used on the boundary. This is called a\n[multi-order coverage (MOC)] map. An example, reproduced from the\n[MOCPy documentation], is shown below.\n\n![An example HEALPix multi-order coverage map](https://cds-astro.github.io/mocpy/_images/plot_SDSS_r.png)\n\nMuch like MOCs, LIGO/Virgo/KAGRA gravitational-wave probability sky maps are\nstored as multi-resolution HEALPix data sets, but with a vector of\nfloating-point values attached to each tile. A multi-order refinement mesh from\nan example sky map is shown below, reproduced from [Singer & Price (2015)].\n\n![Example multi-order refinement mesh from a gravitational-wave probability sky map](https://emfollow.docs.ligo.org/userguide/_images/healpix-adaptive-mesh.svg)\n\n[Reinecke & Hivon (2015)][multi-order] introduced HEALPix interval sets as an\nalternative encoding of MOCs that enables fast and simple unions,\nintersections, and queries. In an interval set, each HEALPix tile is described\nby the interval of pixel indices at some very high resolution\n_level_<sub>max</sub> that are descendents of that tile. In an interval set, a\nregion is encoded as a disjoint collection of such intervals. A tile with a\nNESTED address given by (_level_, _ipix_) may be described as the half-open\ninterval\n\n[_ipix_ 4<sup>_level_<sub>max</sub> - _level_</sup>,\n(_ipix_ + 1) 4<sup>_level_<sub>max</sub> - _level_</sup>).\n\nWe use _level_<sub>max</sub> = 29 because this is the highest resolution at\nwhich pixel indices can be stored in a signed 64-bit integer. At this\nresolution, each pixel is scarcely 0.4 milliarcseconds across.\n\nThe interval set representation is adventageous because there are simple and\nfast algorithms for interval arithmetic and set operations. Interval analysis\nappears in a suprising variety of scientific contexts from [genomics][pyranges]\nto [gravitational wave data quality][ligo-segments]. Because of the many\nbusiness applications of interval arithmetic, intervals are also supported in\nthe [PostgreSQL] database through its [range types].\n\n### Spatial primitives in `healpix_alchemy`\n\nThe `healpix_alchemy` package provides two [custom column types] for\n[SQLAlchemy]:\n\n#### `healpix_alchemy.Point`\n\nThis class represents a point. A column of this type could store the positions\nof galaxies in a catalog. Under the hood, it is just a `BIGINT`.\n\nWherever you need to bind a Python value to a `healpix_alchemy.Point`, you may\nprovide any one of the following:\n* an instance of [astropy.coordinates.SkyCoord]\n* a sequence of two [astropy.units.Quantity] instances with angle units, which\n  will be interpreted as the right ascension and declination of the point in\n  the [ICRS] frame\n* an integer representing the HEALPix NESTED index of the point at\n  _level_ = _level_<sub>max</sub>\n\n#### `healpix_alchemy.Tile`\n\nThis class represents a HEALPix tile. A table containing a column of this type\nand a foreign key could store MOCs or gravitational-wave probability maps.\nUnder the hood, it is just an `INT8RANGE`.\n\nWherever you need to bind a Python value to a `healpix_alchemy.Tile`, you may\nprovide any one of the following:\n* A single integer which will be interpreted as the address of the tile in the\n  [UNIQ] HEALPix indexing scheme\n* A sequence of two integers, which will be interpreted as the lower and upper\n  bounds of the right-half-open pixel index interval at\n  _level_ = _level_<sub>max</sub>\n* A string like `'[1234,5678)'`\n\n## Installation\n\nYou can install `healpix_alchemy` from the Python Package Index using [pip]:\n\n```console\n$ pip install healpix-alchemy\n```\n\n## Development Installation\n\nContributions are welcome! This package uses the [Poetry] packaging and\ndependency tool and [pytest] for unit tests. To install `healpix_alchemy` in a\ndevelopment environment, follow these instructions.\n\n1.  Install [Poetry] by following the\n    [official Poetry installation instructions].\n\n2.  Clone this repository:\n\n    ```console\n    $ git clone https://github.com/skyportal/healpix-alchemy.git\n    $ cd healpix-alchemy\n    ```\n\n3.  Initialize the Poetry-managed virtual environment with `healpix_alchemy`\n    and all of its dependencies installed by running this command:\n\n    ```console\n    $ poetry install\n    ```\n\n    Now, you can enter a shell inside the virtual environment by running:\n\n    ```console\n    $ poetry shell\n    ```\n\n4.  To run the test suite, including the examples in this README file, run this\n    command inside the Poetry shell:\n\n    ```console\n    $ pytest\n    ```\n\n## Example\n\nFirst, some imports:\n\n```pycon\n>>> import sqlalchemy as sa\n>>> from sqlalchemy.ext.declarative import as_declarative, declared_attr\n>>> import healpix_alchemy as ha\n\n```\n\n### Set up tables\n\nThis example will use the SQLAlchemy declarative extension for describing table\nschema using Python classes.\n\nSQLAlchemy needs to know the name for each table. You can provide the name by\nsetting the `__tablename__` attribute in each model class, or you can\ncreate a base class that generates the table name automatically from the class\nname.\n\n```pycon\n>>> @as_declarative()\n... class Base:\n...\n...     @declared_attr\n...     def __tablename__(cls):\n...         return cls.__name__.lower()\n\n```\n\nEach row of the `Galaxy` table represents a point in a catalog:\n\n```pycon\n>>> class Galaxy(Base):\n...     id = sa.Column(sa.Text, primary_key=True)\n...     hpx = sa.Column(ha.Point, index=True, nullable=False)\n\n```\n\nEach row of the `Field` table represents a ZTF field:\n\n```pycon\n>>> class Field(Base):\n...     id = sa.Column(sa.Integer, primary_key=True)\n...     tiles = sa.orm.relationship(lambda: FieldTile)\n\n```\n\nEach row of the `FieldTile` table represents a multi-resolution HEALPix tile\nthat is contained within the corresponding field. There is a one-to-many\nmapping between `Field` and `FieldTile`.\n\n```pycon\n>>> class FieldTile(Base):\n...     id = sa.Column(sa.ForeignKey(Field.id), primary_key=True)\n...     hpx = sa.Column(ha.Tile, primary_key=True, index=True)\n\n```\n\nEach row of the `Skymap` table represents a LIGO/Virgo HEALPix\nlocalization map.\n\n```pycon\n>>> class Skymap(Base):\n...     id = sa.Column(sa.Integer, primary_key=True)\n...     tiles = sa.orm.relationship(lambda: SkymapTile)\n\n```\n\nEach row of the `SkymapTile` table represents a multi-resolution HEALPix\ntile within a LIGO/Virgo localization map. There is a one-to-many mapping\nbetween `Skymap` and `SkymapTile`.\n\n```pycon\n>>> class SkymapTile(Base):\n...     id = sa.Column(sa.ForeignKey(Skymap.id), primary_key=True)\n...     hpx = sa.Column(ha.Tile, primary_key=True, index=True)\n...     probdensity = sa.Column(sa.Float, nullable=False)\n\n```\n\nFinally, connect to the database, create all the tables, and start a session.\n\n```pycon\n>>> engine = sa.create_engine('postgresql://user:password@host/database')\n>>> Base.metadata.create_all(engine)\n>>> session = sa.orm.Session(engine)\n\n```\n\n### Populate with sample data\n\nLoad the [2MASS Redshift Survey] into the `Galaxy` table. This catalog contains\n44599 galaxies.\n\nIt may take up to a minute for this to finish. Advanced users may speed this up\nsignificantly by vectorizing the conversion from `SkyCoord` to HEALPix indices\nand using [SQLAlchemy bulk insertion].\n\n```pycon\n>>> from astropy.coordinates import SkyCoord\n>>> from astroquery.vizier import Vizier\n>>> vizier = Vizier(columns=['SimbadName', 'RAJ2000', 'DEJ2000'], row_limit=-1)\n>>> data, = vizier.get_catalogs('J/ApJS/199/26/table3')\n>>> data['coord'] = SkyCoord(data['RAJ2000'], data['DEJ2000'])\n>>> for row in data:\n...     session.add(Galaxy(id=row['SimbadName'], hpx=row['coord']))\n>>> session.commit()\n\n```\n\nLoad the footprints of the [Zwicky Transient Facility] fields into the `Field`\nand `FieldTile` tables.\n\nIt may take up to a minute for this to finish. Advanced users may speed this up\nsignificantly by using [SQLAlchemy bulk insertion].\n\n```pycon\n>>> from astropy.table import Table\n>>> from astropy.coordinates import SkyCoord\n>>> from astropy import units as u\n>>> url = 'https://raw.githubusercontent.com/ZwickyTransientFacility/ztf_information/master/field_grid/ztf_field_corners.csv'\n>>> for row in Table.read(url):\n...     field_id = int(row['field'])\n...     corners = SkyCoord(row['ra1', 'ra2', 'ra3', 'ra4'],\n...                        row['dec1', 'dec2', 'dec3', 'dec4'],\n...                        unit=u.deg)\n...     tiles = [FieldTile(hpx=hpx) for hpx in ha.Tile.tiles_from(corners)]\n...     session.add(Field(id=field_id, tiles=tiles))\n>>> session.commit()\n\n```\n\nLoad a sky map for LIGO/Virgo event [GW200115_042309] ([S200115j]) into the\n`Skymap` and `SkymapTile` tables.\n\n```pycon\n>>> url = 'https://gracedb.ligo.org/apiweb/superevents/S200115j/files/bayestar.multiorder.fits'\n>>> data = Table.read(url)\n>>> tiles = [SkymapTile(hpx=row['UNIQ'], probdensity=row['PROBDENSITY']) for row in data]\n>>> session.add(Skymap(id=1, tiles=tiles))\n>>> session.commit()\n\n```\n\n### Sample Queries\n\n#### What is the area of each field?\n\n```pycon\n>>> query = sa.select(\n...     FieldTile.id, sa.func.sum(FieldTile.hpx.area)\n... ).group_by(\n...     FieldTile.id\n... ).limit(\n...     5\n... )\n>>> for id, area in session.execute(query):\n...     print(f'Field {id} has area {area:.3g} sr')\nField 199 has area 0.0174 sr\nField 200 has area 0.0174 sr\nField 201 has area 0.0174 sr\nField 202 has area 0.0174 sr\nField 203 has area 0.0174 sr\n\n```\n\n#### How many galaxies are in each field?\n\n```pycon\n>>> count = sa.func.count(Galaxy.id)\n>>> query = sa.select(\n...     FieldTile.id, count\n... ).filter(\n...     FieldTile.hpx.contains(Galaxy.hpx)\n... ).group_by(\n...     FieldTile.id\n... ).order_by(\n...     count.desc()\n... ).limit(\n...     5\n... )\n>>> for id, n in session.execute(query):\n...     print(f'Field {id} contains {n} galaxies')\nField 1739 contains 343 galaxies\nField 699 contains 336 galaxies\nField 700 contains 311 galaxies\nField 225 contains 303 galaxies\nField 1740 contains 289 galaxies\n\n```\n\n#### What is the probability density at the position of each galaxy?\n\n```pycon\n>>> query = sa.select(\n...     Galaxy.id, SkymapTile.probdensity\n... ).filter(\n...     SkymapTile.id == 1,\n...     SkymapTile.hpx.contains(Galaxy.hpx)\n... ).order_by(\n...     SkymapTile.probdensity.desc()\n... ).limit(\n...     5\n... )\n>>> for id, p in session.execute(query):\n...     print(f'{id} has prob. density {p:.5g}/sr')\n2MASX J02532153+0632222 has prob. density 20.701/sr\n2MASX J02530482+0555431 has prob. density 20.695/sr\n2MASX J02533119+0628252 has prob. density 20.669/sr\n2MASX J02524584+0639206 has prob. density 20.656/sr\n2MASX J02534120+0615562 has prob. density 20.567/sr\n\n```\n\n#### What is the probability contained within each field?\n\n```pycon\n>>> area = (FieldTile.hpx * SkymapTile.hpx).area\n>>> prob = sa.func.sum(SkymapTile.probdensity * area)\n>>> query = sa.select(\n...     FieldTile.id, prob\n... ).filter(\n...     SkymapTile.id == 1,\n...     FieldTile.hpx.overlaps(SkymapTile.hpx)\n... ).group_by(\n...     FieldTile.id\n... ).order_by(\n...     prob.desc()\n... ).limit(\n...     5\n... )\n>>> for id, prob in engine.execute(query):\n...     print(f'Field {id} probability is {prob:.3g}')\nField 1499 probability is 0.165\nField 1446 probability is 0.156\nField 452 probability is 0.154\nField 505 probability is 0.0991\nField 401 probability is 0.0962\n\n```\n\n#### What is the combined area of fields 1000 through 2000?\n\nIn the next two examples, we introduce `healpix_alchemy.func.union()` which\nfinds the union of a set of tiles. Because it is an aggregate function, it\nshould generally be used in a subquery.\n\n```pycon\n>>> union = sa.select(\n...     ha.func.union(FieldTile.hpx).label('hpx')\n... ).filter(\n...     FieldTile.id.between(1000, 2000)\n... ).subquery()\n>>> query = sa.select(\n...     sa.func.sum(union.columns.hpx.area)\n... )\n>>> result = session.execute(query).scalar_one()\n>>> print(f'{result:.3g} sr')\n9.33 sr\n\n```\n\n#### What is the integrated probability contained within fields 1000 through 2000?\n\n```pycon\n>>> union = sa.select(\n...     ha.func.union(FieldTile.hpx).label('hpx')\n... ).filter(\n...     FieldTile.id.between(1000, 2000)\n... ).subquery()\n>>> prob = sa.func.sum(SkymapTile.probdensity * (union.columns.hpx * SkymapTile.hpx).area)\n>>> query = sa.select(\n...     prob\n... ).filter(\n...     SkymapTile.id == 1,\n...     union.columns.hpx.overlaps(SkymapTile.hpx)\n... )\n>>> result = session.execute(query).scalar_one()\n>>> print(f'{result:.3g}')\n0.837\n\n```\n\n#### What is the area of the 90% credible region?\n\n```pycon\n>>> cum_area = sa.func.sum(\n...     SkymapTile.hpx.area\n... ).over(\n...     order_by=SkymapTile.probdensity.desc()\n... ).label(\n...     'cum_area'\n... )\n>>> cum_prob = sa.func.sum(\n...     SkymapTile.probdensity * SkymapTile.hpx.area\n... ).over(\n...     order_by=SkymapTile.probdensity.desc()\n... ).label(\n...     'cum_prob'\n... )\n>>> subquery = sa.select(\n...     cum_area,\n...     cum_prob\n... ).filter(\n...     SkymapTile.id == 1\n... ).subquery()\n>>> query = sa.select(\n...     sa.func.max(subquery.columns.cum_area)\n... ).filter(\n...     subquery.columns.cum_prob <= 0.9\n... )\n>>> result = session.execute(query).scalar_one()\n>>> print(f'{result:.3g} sr')\n0.277 sr\n\n```\n\n#### Which galaxies are within the 90% credible region?\n\n```pycon\n>>> cum_prob = sa.func.sum(\n...     SkymapTile.probdensity * SkymapTile.hpx.area\n... ).over(\n...     order_by=SkymapTile.probdensity.desc()\n... ).label(\n...     'cum_prob'\n... )\n>>> subquery1 = sa.select(\n...     SkymapTile.probdensity,\n...     cum_prob\n... ).filter(\n...     SkymapTile.id == 1\n... ).subquery()\n>>> min_probdensity = sa.select(\n...     sa.func.min(subquery1.columns.probdensity)\n... ).filter(\n...     subquery1.columns.cum_prob <= 0.9\n... ).scalar_subquery()\n>>> query = sa.select(\n...     Galaxy.id\n... ).filter(\n...     SkymapTile.id == 1,\n...     SkymapTile.hpx.contains(Galaxy.hpx),\n...     SkymapTile.probdensity >= min_probdensity\n... ).limit(\n...     5\n... )\n>>> for galaxy_id, in session.execute(query):\n...     print(galaxy_id)\n2MASX J02424077-0000478\n2MASX J02352772-0921216\n2MASX J02273746-0109226\n2MASX J02414523+0026354\n2MASX J20095408-4822462\n\n```\n",
    'author': 'Leo Singer',
    'author_email': 'leo.singer@ligo.org',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/skyportal/healpix-alchemy',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
