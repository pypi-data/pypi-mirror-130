# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['comments', 'comments.migrations', 'comments.templatetags']

package_data = \
{'': ['*'],
 'comments': ['static/css/*',
              'static/img/favicons/*',
              'templates/*',
              'templates/base_template/*',
              'templates/comment/*']}

install_requires = \
['Django>=3.2,<4.0',
 'django-crispy-forms>=1.13.0,<2.0.0',
 'django-extensions>=3.1.5,<4.0.0']

setup_kwargs = {
    'name': 'django-add-comments',
    'version': '0.0.1',
    'description': 'Add and display htmx comments to arbitrary Django models.',
    'long_description': '# Comments\n\n## Overview\n\nEnable basic commenting functionality for an arbitrary Django model that contains an `AbstractCommentable` mixin class.\n\n```python\nfrom comments.models import AbstractCommentable\n\n# sentinels/models.py\nclass Sentinel(AbstractCommentable): # arbitrary\n    title = models.CharField(max_length=50)\n    ...\n\n# comments/models.py\nclass AbstractCommentable(models.Model): # generic foreign relationships to comments\n    comments = GenericRelation(Comment, related_query_name="%(app_label)s_%(class)ss")\n\n    class Meta:\n        abstract = True\n```\n\n## Premises\n\nAny model e.g. `Essay`, `Article`, etc... and (not just `Sentinel`) can be "commentable". But for purposes of demonstration, we\'ll use "sentinel" to refer to the arbitrary model that will have its own `comments` field.\n\nMore specifically, the instances of such sentinel – e.g. Sentinel with _id=1_, Sentinel with _id=2_, etc. – need to have their own related comments. This means having the ability to:\n\n1. View a list of existing comments on sentinel _id=1_\n2. Adding a comment (if logged in) on sentinel _id=2_\n3. Deleting a comment (if made by an `author`)\n4. Updating an added comment\'s `content` (if made by an `author`)\n5. Toggling visibility of the comment to the public.\n\nAll instances of the `Sentinel` model therefore will need their own commenting actions. This app produces those actions through urls. See the following shell commands that show the desired url routes per sentinel instance:\n\n```zsh\n# instance is made, e.g. id=1, id=2, etc.\n>>> obj = Sentinel.objects.create(title="A sample title")\n\n# distinguish a `Sentinel` model with comments from an `Essay` model with comments using the app_name\n>>> from sentinels.urls import app_name # required\n>>> obj.add_comment_url # url to add a comment to `A sample title`\n```\n\n### Set sentinel namespace\n\nThe `app_name` namespace can be set/found in the `Sentinel`\'s urls.py:\n\n```python\n# sentinels/urls.py\nfrom .views import SentinelListView\n\napp_name = "sentinels" # this is the namespace\nurlpatterns = [path("", SentinelListView.as_view(), name="sentinel_list"), ...]\n```\n\nThus, the `namespace` / `app_name` becomes `sentinels` and can produce a URL via a reverse function:\n\n```python\nfrom django.urls import reverse\nreverse("sentinels:sentinel_list") # results in the url that will call `SentinelListView.as_view()`\n```\n\n### Add sentinel properties\n\nCopy and paste an attribute to the `Sentinel` model:\n\n```python\n# sentinels/models.py\nfrom comments.models import AbstractCommentable\nclass Sentinel(AbstractCommentable):\n    ...\n    @cached_property\n    def add_comment_url(self) -> str:\n        from .urls import app_name\n\n        return reverse(f"{app_name}:hx_comment_adder", kwargs={"pk": self.pk})\n```\n\nAssuming a sentinel instance `obj`, the declared property will enable the use of `add_comment_url`.\n\n### Add sentinel-comment views\n\nCopy and paste the _view_:\n\n```python\n# sentinels/views.py\nfrom comments.views import hx_add_comment_to_target_obj\nfrom comments.models import Comment\nfrom .models import Sentinel\n\ndef hx_comment_adder(request: HttpRequest, pk: int) -> TemplateResponse:\n    obj = Sentinel.objects.get(pk=pk)\n    return hx_add_comment_to_target_obj(request, obj)\n```\n\n### Add sentinel-comment urls\n\nAdd the created _view_ function to a _url_.\n\n```python\n# sentinels/urls.py\nfrom .views import hx_comment_adder\n\napp_name = "sentinels"\nurl_patterns = [path("add_coment/target/<int:pk>", hx_comment_adder, name="hx_comment_adder"), ...]\n```\n\nWith this done, the following route, `obj.add_comment_url` becomes operational:\n\n```python\nfrom django.urls import reverse\nreverse("sentinels:hx_comment_adder", kwargs={"pk":pk})\n```\n\n### Sentinel instances will now have access to comment urls\n\nSee `obj.add_comment_url` as used in a [template tag](./comments/templatetags/comments.py). The form that represents this "add comment" action / url will be loaded in every comment list:\n\n```jinja\n<!-- sentinels/templates/sentinel_detail.html -->\n<h1>Title: {{ object.title }}</h1>\n{% load comments %} <!-- see templatetags/comments.py -->\n{% list_comments %}\n```\n\n### Load comment form in sentinel view\n\nThe basic view does not yet show a comment form.\n\nWhen the `htmx`-ed `<div>` is loaded to the DOM, however, a few things happen because of the insertion of attributes in the `add_comment_template`:\n\n```jinja\n<!-- comments/templates/inserter.html -->\n...\n<section>\n    <div hx-trigger="load" hx-get="{{form_url}}" hx-target="this" hx-swap="innerHTML">\n    </div>\n</section>\n...\n\n{% if inserted %}\n    {% include \'./card.html\' with comment=inserted %}\n{% endif %}\n```\n\nThe loading of the `<div>` triggers a `GET` request to the `form_url` aka `obj.add_comment_url`. The response is swapped into the DOM, replacing `this` blank div with a rendered `<form></form>`, i.e. `InputCommentModelForm`.\n\nNo page refresh was done, courtesy of html-sent-over-the-wire.\n\n### Comment added to the top of the sentinel view, without page refresh\n\nNote that in the above `inserter` template, an `inserted` variable is declared:\n\n```jinja\n...\n{% if inserted %}\n    {% include \'../card.html\' with comment=inserted %}\n{% endif %}\n```\n\nWhen the fields of the instantiated form is populated and submitted, a `POST` request is sent to the same `hx_comment_adder` url.\n\nThe response targets the entire `<section>` because of the form\'s `<submit>` attributes declared via django-crispy-forms but it will replace the entire html fragment above because of swapping "outerHTML" (on the div) response from `POST`:\n\n```python\n# comments/forms.py\nfrom crispy_forms.layout import Submit\n...\nSubmit(\n    "submit",\n    "Submit",\n    hx_post=submit_url, # i.e. `hx_comment_adder`\n    hx_target=f"closest section", # see comments/templates/inserter.html\n    hx_swap="outerHTML",\n    hx_trigger="click",\n)\n# comments/views.py\nfrom django.template.response import TemplateResponse\ndef hx_add_comment_to_target_obj(request: HttpRequest, target_obj: ContentType):\n    ...\n    if request.method == "POST" and form.is_valid():\n        return TemplateResponse(\n                request,\n                "comment/inserter.html", # see comments/templates/inserter.html\n                {\n                    "inserted": comment, # newly inserted comment at the top of the list of comments\n                    "form_url": request.path, # reloads the form because of hx-trigger "load"\n                    "label": "Add Comment",\n                },\n            )\n    ...\n```\n\nThe `add_comment_template` is then reset:\n\n1. The user can add a new comment since the form is replaced with an empty one;\n2. The recently `inserted` comment is reflected at the top of the list of comments.\n3. No page refresh is done, against courtesty of htmx.\n\n### Repeat the process for other models\n\n1. The procedure above was undertaken with respect to the `Sentinel` model.\n2. For another Django app, let\'s say `articles` with an `Article` model, the same procedure can be followed.\n',
    'author': 'Marcelino G. Veloso III',
    'author_email': 'mars@veloso.one',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/justmars/django-add-comments',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
