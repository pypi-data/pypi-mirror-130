# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from akkaserverless.akkaserverless.akkaserverless.akkaserverless.akkaserverless.akkaserverless.component.action import action_pb2 as akkaserverless_dot_component_dot_action_dot_action__pb2


class ActionsStub(object):
    """Service that the SDK (in the user function) implements to make actions
    available to the proxy
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.HandleUnary = channel.unary_unary(
                '/akkaserverless.component.action.Actions/HandleUnary',
                request_serializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.SerializeToString,
                response_deserializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.FromString,
                )
        self.HandleStreamedIn = channel.stream_unary(
                '/akkaserverless.component.action.Actions/HandleStreamedIn',
                request_serializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.SerializeToString,
                response_deserializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.FromString,
                )
        self.HandleStreamedOut = channel.unary_stream(
                '/akkaserverless.component.action.Actions/HandleStreamedOut',
                request_serializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.SerializeToString,
                response_deserializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.FromString,
                )
        self.HandleStreamed = channel.stream_stream(
                '/akkaserverless.component.action.Actions/HandleStreamed',
                request_serializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.SerializeToString,
                response_deserializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.FromString,
                )


class ActionsServicer(object):
    """Service that the SDK (in the user function) implements to make actions
    available to the proxy
    """

    def HandleUnary(self, request, context):
        """Handle a unary command.

        The input command will contain the service name, command name, request
        metadata and the command payload. The reply may contain a direct reply, a
        forward or a failure, and it may contain many side effects.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def HandleStreamedIn(self, request_iterator, context):
        """Handle a streamed in command.

        The first message in will contain the request metadata, including the
        service name and command name. It will not have an associated payload set.
        This will be followed by zero to many messages in with a payload, but no
        service name or command name set.

        If the underlying transport supports per stream metadata, rather than per
        message metadata, then that metadata will only be included in the metadata
        of the first message. In contrast, if the underlying transport supports per
        message metadata, there will be no metadata on the first message, the
        metadata will instead be found on each subsequent message.

        The semantics of stream closure in this protocol map 1:1 with the semantics
        of gRPC stream closure, that is, when the client closes the stream, the
        stream is considered half closed, and the server should eventually, but not
        necessarily immediately, send a response message with a status code and
        trailers.

        If however the server sends a response message before the client closes the
        stream, the stream is completely closed, and the client should handle this
        and stop sending more messages.

        Either the client or the server may cancel the stream at any time,
        cancellation is indicated through an HTTP2 stream RST message.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def HandleStreamedOut(self, request, context):
        """Handle a streamed out command.

        The input command will contain the service name, command name, request
        metadata and the command payload. Zero or more replies may be sent, each
        containing either a direct reply, a forward or a failure, and each may
        contain many side effects. The stream to the client will be closed when the
        this stream is closed, with the same status as this stream is closed with.

        Either the client or the server may cancel the stream at any time,
        cancellation is indicated through an HTTP2 stream RST message.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def HandleStreamed(self, request_iterator, context):
        """Handle a full duplex streamed command.

        The first message in will contain the request metadata, including the
        service name and command name. It will not have an associated payload set.
        This will be followed by zero to many messages in with a payload, but no
        service name or command name set.

        Zero or more replies may be sent, each containing either a direct reply, a
        forward or a failure, and each may contain many side effects.

        If the underlying transport supports per stream metadata, rather than per
        message metadata, then that metadata will only be included in the metadata
        of the first message. In contrast, if the underlying transport supports per
        message metadata, there will be no metadata on the first message, the
        metadata will instead be found on each subsequent message.

        The semantics of stream closure in this protocol map 1:1 with the semantics
        of gRPC stream closure, that is, when the client closes the stream, the
        stream is considered half closed, and the server should eventually, but not
        necessarily immediately, close the stream with a status code and trailers.

        If however the server closes the stream with a status code and trailers,
        the stream is immediately considered completely closed, and no further
        messages sent by the client will be handled by the server.

        Either the client or the server may cancel the stream at any time,
        cancellation is indicated through an HTTP2 stream RST message.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_ActionsServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'HandleUnary': grpc.unary_unary_rpc_method_handler(
                    servicer.HandleUnary,
                    request_deserializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.FromString,
                    response_serializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.SerializeToString,
            ),
            'HandleStreamedIn': grpc.stream_unary_rpc_method_handler(
                    servicer.HandleStreamedIn,
                    request_deserializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.FromString,
                    response_serializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.SerializeToString,
            ),
            'HandleStreamedOut': grpc.unary_stream_rpc_method_handler(
                    servicer.HandleStreamedOut,
                    request_deserializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.FromString,
                    response_serializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.SerializeToString,
            ),
            'HandleStreamed': grpc.stream_stream_rpc_method_handler(
                    servicer.HandleStreamed,
                    request_deserializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.FromString,
                    response_serializer=akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'akkaserverless.component.action.Actions', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Actions(object):
    """Service that the SDK (in the user function) implements to make actions
    available to the proxy
    """

    @staticmethod
    def HandleUnary(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/akkaserverless.component.action.Actions/HandleUnary',
            akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.SerializeToString,
            akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def HandleStreamedIn(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_unary(request_iterator, target, '/akkaserverless.component.action.Actions/HandleStreamedIn',
            akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.SerializeToString,
            akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def HandleStreamedOut(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/akkaserverless.component.action.Actions/HandleStreamedOut',
            akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.SerializeToString,
            akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def HandleStreamed(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(request_iterator, target, '/akkaserverless.component.action.Actions/HandleStreamed',
            akkaserverless_dot_component_dot_action_dot_action__pb2.ActionCommand.SerializeToString,
            akkaserverless_dot_component_dot_action_dot_action__pb2.ActionResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
