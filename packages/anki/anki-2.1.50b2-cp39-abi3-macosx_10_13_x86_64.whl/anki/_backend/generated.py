# Copyright: Ankitects Pty Ltd and contributors
# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html
# pylint: skip-file

from __future__ import annotations

"""
THIS FILE IS AUTOMATICALLY GENERATED - DO NOT EDIT.

Please do not access methods on the backend directly - they may be changed
or removed at any time. Instead, please use the methods on the collection
instead. Eg, don't use col.backend.all_deck_config(), instead use
col.decks.all_config()
"""
    
from typing import *

import anki
import anki.backend_pb2
import anki.i18n_pb2
import anki.cards_pb2
import anki.collection_pb2
import anki.decks_pb2
import anki.deckconfig_pb2
import anki.links_pb2
import anki.notes_pb2
import anki.notetypes_pb2
import anki.scheduler_pb2
import anki.sync_pb2
import anki.config_pb2
import anki.search_pb2
import anki.stats_pb2
import anki.card_rendering_pb2
import anki.tags_pb2
import anki.media_pb2

class RustBackendGenerated:
    def _run_command(self, service: int, method: int, input: Any) -> bytes:
        raise Exception("not implemented")
    
    def get_queued_cards(self, *, fetch_limit: int, intraday_learning_only: bool) -> anki.scheduler_pb2.QueuedCards:
        input = anki.scheduler_pb2.GetQueuedCardsRequest(fetch_limit=fetch_limit, intraday_learning_only=intraday_learning_only)
        output = anki.scheduler_pb2.QueuedCards()
        output.ParseFromString(self._run_command(0, 0, input))
        return output

    def answer_card(self, input: anki.scheduler_pb2.CardAnswer) -> anki.collection_pb2.OpChanges:
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(0, 1, input))
        return output

    def sched_timing_today(self) -> anki.scheduler_pb2.SchedTimingTodayResponse:
        input = anki.generic_pb2.Empty()
        output = anki.scheduler_pb2.SchedTimingTodayResponse()
        output.ParseFromString(self._run_command(0, 2, input))
        return output

    def studied_today(self) -> str:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(0, 3, input))
        return output.val

    def studied_today_message(self, *, cards: int, seconds: float) -> str:
        input = anki.scheduler_pb2.StudiedTodayMessageRequest(cards=cards, seconds=seconds)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(0, 4, input))
        return output.val

    def update_stats(self, *, deck_id: int, new_delta: int, review_delta: int, millisecond_delta: int) -> anki.generic_pb2.Empty:
        input = anki.scheduler_pb2.UpdateStatsRequest(deck_id=deck_id, new_delta=new_delta, review_delta=review_delta, millisecond_delta=millisecond_delta)
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(0, 5, input))
        return output

    def extend_limits(self, *, deck_id: int, new_delta: int, review_delta: int) -> anki.generic_pb2.Empty:
        input = anki.scheduler_pb2.ExtendLimitsRequest(deck_id=deck_id, new_delta=new_delta, review_delta=review_delta)
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(0, 6, input))
        return output

    def counts_for_deck_today(self, did: int) -> anki.scheduler_pb2.CountsForDeckTodayResponse:
        input = anki.decks_pb2.DeckId(did=did)
        output = anki.scheduler_pb2.CountsForDeckTodayResponse()
        output.ParseFromString(self._run_command(0, 7, input))
        return output

    def congrats_info(self) -> anki.scheduler_pb2.CongratsInfoResponse:
        input = anki.generic_pb2.Empty()
        output = anki.scheduler_pb2.CongratsInfoResponse()
        output.ParseFromString(self._run_command(0, 8, input))
        return output

    def restore_buried_and_suspended_cards(self, cids: Sequence[int]) -> anki.collection_pb2.OpChanges:
        input = anki.cards_pb2.CardIds(cids=cids)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(0, 9, input))
        return output

    def unbury_deck(self, *, deck_id: int, mode: anki.scheduler_pb2.UnburyDeckRequest.Mode.V) -> anki.collection_pb2.OpChanges:
        input = anki.scheduler_pb2.UnburyDeckRequest(deck_id=deck_id, mode=mode)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(0, 10, input))
        return output

    def bury_or_suspend_cards(self, *, card_ids: Sequence[int], note_ids: Sequence[int], mode: anki.scheduler_pb2.BuryOrSuspendCardsRequest.Mode.V) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.scheduler_pb2.BuryOrSuspendCardsRequest(card_ids=card_ids, note_ids=note_ids, mode=mode)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 11, input))
        return output

    def empty_filtered_deck(self, did: int) -> anki.collection_pb2.OpChanges:
        input = anki.decks_pb2.DeckId(did=did)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(0, 12, input))
        return output

    def rebuild_filtered_deck(self, did: int) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.decks_pb2.DeckId(did=did)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 13, input))
        return output

    def schedule_cards_as_new(self, *, card_ids: Sequence[int], log: bool) -> anki.collection_pb2.OpChanges:
        input = anki.scheduler_pb2.ScheduleCardsAsNewRequest(card_ids=card_ids, log=log)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(0, 14, input))
        return output

    def set_due_date(self, *, card_ids: Sequence[int], days: str, config_key: anki.config_pb2.OptionalStringConfigKey) -> anki.collection_pb2.OpChanges:
        input = anki.scheduler_pb2.SetDueDateRequest(card_ids=card_ids, days=days, config_key=config_key)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(0, 15, input))
        return output

    def sort_cards(self, *, card_ids: Sequence[int], starting_from: int, step_size: int, randomize: bool, shift_existing: bool) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.scheduler_pb2.SortCardsRequest(card_ids=card_ids, starting_from=starting_from, step_size=step_size, randomize=randomize, shift_existing=shift_existing)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 16, input))
        return output

    def sort_deck(self, *, deck_id: int, randomize: bool) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.scheduler_pb2.SortDeckRequest(deck_id=deck_id, randomize=randomize)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 17, input))
        return output

    def get_next_card_states(self, cid: int) -> anki.scheduler_pb2.NextCardStates:
        input = anki.cards_pb2.CardId(cid=cid)
        output = anki.scheduler_pb2.NextCardStates()
        output.ParseFromString(self._run_command(0, 18, input))
        return output

    def describe_next_states(self, input: anki.scheduler_pb2.NextCardStates) -> Sequence[str]:
        output = anki.generic_pb2.StringList()
        output.ParseFromString(self._run_command(0, 19, input))
        return output.vals

    def state_is_leech(self, input: anki.scheduler_pb2.SchedulingState) -> bool:
        output = anki.generic_pb2.Bool()
        output.ParseFromString(self._run_command(0, 20, input))
        return output.val

    def upgrade_scheduler(self) -> anki.generic_pb2.Empty:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(0, 21, input))
        return output

    def add_deck_legacy(self, json: bytes) -> anki.collection_pb2.OpChangesWithId:
        input = anki.generic_pb2.Json(json=json)
        output = anki.collection_pb2.OpChangesWithId()
        output.ParseFromString(self._run_command(1, 0, input))
        return output

    def add_or_update_deck_legacy(self, *, deck: bytes, preserve_usn_and_mtime: bool) -> int:
        input = anki.decks_pb2.AddOrUpdateDeckLegacyRequest(deck=deck, preserve_usn_and_mtime=preserve_usn_and_mtime)
        output = anki.decks_pb2.DeckId()
        output.ParseFromString(self._run_command(1, 1, input))
        return output.did

    def deck_tree(self, *, now: int, top_deck_id: int) -> anki.decks_pb2.DeckTreeNode:
        input = anki.decks_pb2.DeckTreeRequest(now=now, top_deck_id=top_deck_id)
        output = anki.decks_pb2.DeckTreeNode()
        output.ParseFromString(self._run_command(1, 2, input))
        return output

    def deck_tree_legacy(self) -> bytes:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(1, 3, input))
        return output.json

    def get_all_decks_legacy(self) -> bytes:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(1, 4, input))
        return output.json

    def get_deck_id_by_name(self, val: str) -> int:
        input = anki.generic_pb2.String(val=val)
        output = anki.decks_pb2.DeckId()
        output.ParseFromString(self._run_command(1, 5, input))
        return output.did

    def get_deck(self, did: int) -> anki.decks_pb2.Deck:
        input = anki.decks_pb2.DeckId(did=did)
        output = anki.decks_pb2.Deck()
        output.ParseFromString(self._run_command(1, 6, input))
        return output

    def update_deck(self, input: anki.decks_pb2.Deck) -> anki.collection_pb2.OpChanges:
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(1, 7, input))
        return output

    def update_deck_legacy(self, json: bytes) -> anki.collection_pb2.OpChanges:
        input = anki.generic_pb2.Json(json=json)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(1, 8, input))
        return output

    def set_deck_collapsed(self, *, deck_id: int, collapsed: bool, scope: anki.decks_pb2.SetDeckCollapsedRequest.Scope.V) -> anki.collection_pb2.OpChanges:
        input = anki.decks_pb2.SetDeckCollapsedRequest(deck_id=deck_id, collapsed=collapsed, scope=scope)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(1, 9, input))
        return output

    def get_deck_legacy(self, did: int) -> bytes:
        input = anki.decks_pb2.DeckId(did=did)
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(1, 10, input))
        return output.json

    def get_deck_names(self, *, skip_empty_default: bool, include_filtered: bool) -> Sequence[anki.decks_pb2.DeckNameId]:
        input = anki.decks_pb2.GetDeckNamesRequest(skip_empty_default=skip_empty_default, include_filtered=include_filtered)
        output = anki.decks_pb2.DeckNames()
        output.ParseFromString(self._run_command(1, 11, input))
        return output.entries

    def get_deck_and_child_names(self, did: int) -> Sequence[anki.decks_pb2.DeckNameId]:
        input = anki.decks_pb2.DeckId(did=did)
        output = anki.decks_pb2.DeckNames()
        output.ParseFromString(self._run_command(1, 12, input))
        return output.entries

    def new_deck_legacy(self, val: bool) -> bytes:
        input = anki.generic_pb2.Bool(val=val)
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(1, 13, input))
        return output.json

    def remove_decks(self, dids: Sequence[int]) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.decks_pb2.DeckIds(dids=dids)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(1, 14, input))
        return output

    def reparent_decks(self, *, deck_ids: Sequence[int], new_parent: int) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.decks_pb2.ReparentDecksRequest(deck_ids=deck_ids, new_parent=new_parent)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(1, 15, input))
        return output

    def rename_deck(self, *, deck_id: int, new_name: str) -> anki.collection_pb2.OpChanges:
        input = anki.decks_pb2.RenameDeckRequest(deck_id=deck_id, new_name=new_name)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(1, 16, input))
        return output

    def get_or_create_filtered_deck(self, did: int) -> anki.decks_pb2.FilteredDeckForUpdate:
        input = anki.decks_pb2.DeckId(did=did)
        output = anki.decks_pb2.FilteredDeckForUpdate()
        output.ParseFromString(self._run_command(1, 17, input))
        return output

    def add_or_update_filtered_deck(self, input: anki.decks_pb2.FilteredDeckForUpdate) -> anki.collection_pb2.OpChangesWithId:
        output = anki.collection_pb2.OpChangesWithId()
        output.ParseFromString(self._run_command(1, 18, input))
        return output

    def filtered_deck_order_labels(self) -> Sequence[str]:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.StringList()
        output.ParseFromString(self._run_command(1, 19, input))
        return output.vals

    def set_current_deck(self, did: int) -> anki.collection_pb2.OpChanges:
        input = anki.decks_pb2.DeckId(did=did)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(1, 20, input))
        return output

    def get_current_deck(self) -> anki.decks_pb2.Deck:
        input = anki.generic_pb2.Empty()
        output = anki.decks_pb2.Deck()
        output.ParseFromString(self._run_command(1, 21, input))
        return output

    def new_note(self, ntid: int) -> anki.notes_pb2.Note:
        input = anki.notetypes_pb2.NotetypeId(ntid=ntid)
        output = anki.notes_pb2.Note()
        output.ParseFromString(self._run_command(2, 0, input))
        return output

    def add_note(self, *, note: anki.notes_pb2.Note, deck_id: int) -> anki.notes_pb2.AddNoteResponse:
        input = anki.notes_pb2.AddNoteRequest(note=note, deck_id=deck_id)
        output = anki.notes_pb2.AddNoteResponse()
        output.ParseFromString(self._run_command(2, 1, input))
        return output

    def defaults_for_adding(self, home_deck_of_current_review_card: int) -> anki.notes_pb2.DeckAndNotetype:
        input = anki.notes_pb2.DefaultsForAddingRequest(home_deck_of_current_review_card=home_deck_of_current_review_card)
        output = anki.notes_pb2.DeckAndNotetype()
        output.ParseFromString(self._run_command(2, 2, input))
        return output

    def default_deck_for_notetype(self, ntid: int) -> int:
        input = anki.notetypes_pb2.NotetypeId(ntid=ntid)
        output = anki.decks_pb2.DeckId()
        output.ParseFromString(self._run_command(2, 3, input))
        return output.did

    def update_notes(self, *, notes: Sequence[anki.notes_pb2.Note], skip_undo_entry: bool) -> anki.collection_pb2.OpChanges:
        input = anki.notes_pb2.UpdateNotesRequest(notes=notes, skip_undo_entry=skip_undo_entry)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(2, 4, input))
        return output

    def get_note(self, nid: int) -> anki.notes_pb2.Note:
        input = anki.notes_pb2.NoteId(nid=nid)
        output = anki.notes_pb2.Note()
        output.ParseFromString(self._run_command(2, 5, input))
        return output

    def remove_notes(self, *, note_ids: Sequence[int], card_ids: Sequence[int]) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.notes_pb2.RemoveNotesRequest(note_ids=note_ids, card_ids=card_ids)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(2, 6, input))
        return output

    def cloze_numbers_in_note(self, input: anki.notes_pb2.Note) -> Sequence[int]:
        output = anki.notes_pb2.ClozeNumbersInNoteResponse()
        output.ParseFromString(self._run_command(2, 7, input))
        return output.numbers

    def after_note_updates(self, *, nids: Sequence[int], mark_notes_modified: bool, generate_cards: bool) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.notes_pb2.AfterNoteUpdatesRequest(nids=nids, mark_notes_modified=mark_notes_modified, generate_cards=generate_cards)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(2, 8, input))
        return output

    def field_names_for_notes(self, nids: Sequence[int]) -> Sequence[str]:
        input = anki.notes_pb2.FieldNamesForNotesRequest(nids=nids)
        output = anki.notes_pb2.FieldNamesForNotesResponse()
        output.ParseFromString(self._run_command(2, 9, input))
        return output.fields

    def note_fields_check(self, input: anki.notes_pb2.Note) -> anki.notes_pb2.NoteFieldsCheckResponse:
        output = anki.notes_pb2.NoteFieldsCheckResponse()
        output.ParseFromString(self._run_command(2, 10, input))
        return output

    def cards_of_note(self, nid: int) -> Sequence[int]:
        input = anki.notes_pb2.NoteId(nid=nid)
        output = anki.cards_pb2.CardIds()
        output.ParseFromString(self._run_command(2, 11, input))
        return output.cids

    def get_single_notetype_of_notes(self, note_ids: Sequence[int]) -> int:
        input = anki.notes_pb2.NoteIds(note_ids=note_ids)
        output = anki.notetypes_pb2.NotetypeId()
        output.ParseFromString(self._run_command(2, 12, input))
        return output.ntid

    def sync_media(self, input: anki.sync_pb2.SyncAuth) -> anki.generic_pb2.Empty:
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(3, 0, input))
        return output

    def abort_sync(self) -> anki.generic_pb2.Empty:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(3, 1, input))
        return output

    def abort_media_sync(self) -> anki.generic_pb2.Empty:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(3, 2, input))
        return output

    def before_upload(self) -> anki.generic_pb2.Empty:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(3, 3, input))
        return output

    def sync_login(self, *, username: str, password: str) -> anki.sync_pb2.SyncAuth:
        input = anki.sync_pb2.SyncLoginRequest(username=username, password=password)
        output = anki.sync_pb2.SyncAuth()
        output.ParseFromString(self._run_command(3, 4, input))
        return output

    def sync_status(self, input: anki.sync_pb2.SyncAuth) -> anki.sync_pb2.SyncStatusResponse:
        output = anki.sync_pb2.SyncStatusResponse()
        output.ParseFromString(self._run_command(3, 5, input))
        return output

    def sync_collection(self, input: anki.sync_pb2.SyncAuth) -> anki.sync_pb2.SyncCollectionResponse:
        output = anki.sync_pb2.SyncCollectionResponse()
        output.ParseFromString(self._run_command(3, 6, input))
        return output

    def full_upload(self, input: anki.sync_pb2.SyncAuth) -> anki.generic_pb2.Empty:
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(3, 7, input))
        return output

    def full_download(self, input: anki.sync_pb2.SyncAuth) -> anki.generic_pb2.Empty:
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(3, 8, input))
        return output

    def sync_server_method(self, *, method: anki.sync_pb2.SyncServerMethodRequest.Method.V, data: bytes) -> bytes:
        input = anki.sync_pb2.SyncServerMethodRequest(method=method, data=data)
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(3, 9, input))
        return output.json

    def add_notetype(self, input: anki.notetypes_pb2.Notetype) -> anki.collection_pb2.OpChangesWithId:
        output = anki.collection_pb2.OpChangesWithId()
        output.ParseFromString(self._run_command(4, 0, input))
        return output

    def update_notetype(self, input: anki.notetypes_pb2.Notetype) -> anki.collection_pb2.OpChanges:
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(4, 1, input))
        return output

    def add_notetype_legacy(self, json: bytes) -> anki.collection_pb2.OpChangesWithId:
        input = anki.generic_pb2.Json(json=json)
        output = anki.collection_pb2.OpChangesWithId()
        output.ParseFromString(self._run_command(4, 2, input))
        return output

    def update_notetype_legacy(self, json: bytes) -> anki.collection_pb2.OpChanges:
        input = anki.generic_pb2.Json(json=json)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(4, 3, input))
        return output

    def add_or_update_notetype(self, *, json: bytes, preserve_usn_and_mtime: bool, skip_checks: bool) -> int:
        input = anki.notetypes_pb2.AddOrUpdateNotetypeRequest(json=json, preserve_usn_and_mtime=preserve_usn_and_mtime, skip_checks=skip_checks)
        output = anki.notetypes_pb2.NotetypeId()
        output.ParseFromString(self._run_command(4, 4, input))
        return output.ntid

    def get_stock_notetype_legacy(self, kind: anki.notetypes_pb2.StockNotetype.Kind.V) -> bytes:
        input = anki.notetypes_pb2.StockNotetype(kind=kind)
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(4, 5, input))
        return output.json

    def get_notetype(self, ntid: int) -> anki.notetypes_pb2.Notetype:
        input = anki.notetypes_pb2.NotetypeId(ntid=ntid)
        output = anki.notetypes_pb2.Notetype()
        output.ParseFromString(self._run_command(4, 6, input))
        return output

    def get_notetype_legacy(self, ntid: int) -> bytes:
        input = anki.notetypes_pb2.NotetypeId(ntid=ntid)
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(4, 7, input))
        return output.json

    def get_notetype_names(self) -> Sequence[anki.notetypes_pb2.NotetypeNameId]:
        input = anki.generic_pb2.Empty()
        output = anki.notetypes_pb2.NotetypeNames()
        output.ParseFromString(self._run_command(4, 8, input))
        return output.entries

    def get_notetype_names_and_counts(self) -> Sequence[anki.notetypes_pb2.NotetypeNameIdUseCount]:
        input = anki.generic_pb2.Empty()
        output = anki.notetypes_pb2.NotetypeUseCounts()
        output.ParseFromString(self._run_command(4, 9, input))
        return output.entries

    def get_notetype_id_by_name(self, val: str) -> int:
        input = anki.generic_pb2.String(val=val)
        output = anki.notetypes_pb2.NotetypeId()
        output.ParseFromString(self._run_command(4, 10, input))
        return output.ntid

    def remove_notetype(self, ntid: int) -> anki.collection_pb2.OpChanges:
        input = anki.notetypes_pb2.NotetypeId(ntid=ntid)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(4, 11, input))
        return output

    def get_aux_notetype_config_key(self, *, id: int, key: str) -> str:
        input = anki.notetypes_pb2.GetAuxConfigKeyRequest(id=id, key=key)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(4, 12, input))
        return output.val

    def get_aux_template_config_key(self, *, notetype_id: int, card_ordinal: int, key: str) -> str:
        input = anki.notetypes_pb2.GetAuxTemplateConfigKeyRequest(notetype_id=notetype_id, card_ordinal=card_ordinal, key=key)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(4, 13, input))
        return output.val

    def get_change_notetype_info(self, *, old_notetype_id: int, new_notetype_id: int) -> bytes:
        input = anki.notetypes_pb2.GetChangeNotetypeInfoRequest(old_notetype_id=old_notetype_id, new_notetype_id=new_notetype_id)
        return self._run_command(4, 14, input)

    def change_notetype(self, input: anki.notetypes_pb2.ChangeNotetypeRequest) -> anki.collection_pb2.OpChanges:
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(4, 15, input))
        return output

    def get_config_json(self, val: str) -> bytes:
        input = anki.generic_pb2.String(val=val)
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(5, 0, input))
        return output.json

    def set_config_json(self, *, key: str, value_json: bytes, undoable: bool) -> anki.collection_pb2.OpChanges:
        input = anki.config_pb2.SetConfigJsonRequest(key=key, value_json=value_json, undoable=undoable)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(5, 1, input))
        return output

    def set_config_json_no_undo(self, *, key: str, value_json: bytes, undoable: bool) -> anki.generic_pb2.Empty:
        input = anki.config_pb2.SetConfigJsonRequest(key=key, value_json=value_json, undoable=undoable)
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(5, 2, input))
        return output

    def remove_config(self, val: str) -> anki.collection_pb2.OpChanges:
        input = anki.generic_pb2.String(val=val)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(5, 3, input))
        return output

    def get_all_config(self) -> bytes:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(5, 4, input))
        return output.json

    def get_config_bool(self, key: anki.config_pb2.ConfigKey.Bool.V) -> bool:
        input = anki.config_pb2.GetConfigBoolRequest(key=key)
        output = anki.generic_pb2.Bool()
        output.ParseFromString(self._run_command(5, 5, input))
        return output.val

    def set_config_bool(self, *, key: anki.config_pb2.ConfigKey.Bool.V, value: bool, undoable: bool) -> anki.collection_pb2.OpChanges:
        input = anki.config_pb2.SetConfigBoolRequest(key=key, value=value, undoable=undoable)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(5, 6, input))
        return output

    def get_config_string(self, key: anki.config_pb2.ConfigKey.String.V) -> str:
        input = anki.config_pb2.GetConfigStringRequest(key=key)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(5, 7, input))
        return output.val

    def set_config_string(self, *, key: anki.config_pb2.ConfigKey.String.V, value: str, undoable: bool) -> anki.collection_pb2.OpChanges:
        input = anki.config_pb2.SetConfigStringRequest(key=key, value=value, undoable=undoable)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(5, 8, input))
        return output

    def get_preferences(self) -> anki.config_pb2.Preferences:
        input = anki.generic_pb2.Empty()
        output = anki.config_pb2.Preferences()
        output.ParseFromString(self._run_command(5, 9, input))
        return output

    def set_preferences(self, input: anki.config_pb2.Preferences) -> anki.collection_pb2.OpChanges:
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(5, 10, input))
        return output

    def extract_av_tags(self, *, text: str, question_side: bool) -> anki.card_rendering_pb2.ExtractAVTagsResponse:
        input = anki.card_rendering_pb2.ExtractAVTagsRequest(text=text, question_side=question_side)
        output = anki.card_rendering_pb2.ExtractAVTagsResponse()
        output.ParseFromString(self._run_command(6, 0, input))
        return output

    def extract_latex(self, *, text: str, svg: bool, expand_clozes: bool) -> anki.card_rendering_pb2.ExtractLatexResponse:
        input = anki.card_rendering_pb2.ExtractLatexRequest(text=text, svg=svg, expand_clozes=expand_clozes)
        output = anki.card_rendering_pb2.ExtractLatexResponse()
        output.ParseFromString(self._run_command(6, 1, input))
        return output

    def get_empty_cards(self) -> anki.card_rendering_pb2.EmptyCardsReport:
        input = anki.generic_pb2.Empty()
        output = anki.card_rendering_pb2.EmptyCardsReport()
        output.ParseFromString(self._run_command(6, 2, input))
        return output

    def render_existing_card(self, *, card_id: int, browser: bool) -> anki.card_rendering_pb2.RenderCardResponse:
        input = anki.card_rendering_pb2.RenderExistingCardRequest(card_id=card_id, browser=browser)
        output = anki.card_rendering_pb2.RenderCardResponse()
        output.ParseFromString(self._run_command(6, 3, input))
        return output

    def render_uncommitted_card(self, *, note: anki.notes_pb2.Note, card_ord: int, template: anki.notetypes_pb2.Notetype.Template, fill_empty: bool) -> anki.card_rendering_pb2.RenderCardResponse:
        input = anki.card_rendering_pb2.RenderUncommittedCardRequest(note=note, card_ord=card_ord, template=template, fill_empty=fill_empty)
        output = anki.card_rendering_pb2.RenderCardResponse()
        output.ParseFromString(self._run_command(6, 4, input))
        return output

    def render_uncommitted_card_legacy(self, *, note: anki.notes_pb2.Note, card_ord: int, template: bytes, fill_empty: bool) -> anki.card_rendering_pb2.RenderCardResponse:
        input = anki.card_rendering_pb2.RenderUncommittedCardLegacyRequest(note=note, card_ord=card_ord, template=template, fill_empty=fill_empty)
        output = anki.card_rendering_pb2.RenderCardResponse()
        output.ParseFromString(self._run_command(6, 5, input))
        return output

    def strip_av_tags(self, val: str) -> str:
        input = anki.generic_pb2.String(val=val)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(6, 6, input))
        return output.val

    def render_markdown(self, *, markdown: str, sanitize: bool) -> str:
        input = anki.card_rendering_pb2.RenderMarkdownRequest(markdown=markdown, sanitize=sanitize)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(6, 7, input))
        return output.val

    def encode_iri_paths(self, val: str) -> str:
        input = anki.generic_pb2.String(val=val)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(6, 8, input))
        return output.val

    def decode_iri_paths(self, val: str) -> str:
        input = anki.generic_pb2.String(val=val)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(6, 9, input))
        return output.val

    def strip_html(self, *, text: str, mode: anki.card_rendering_pb2.StripHtmlRequest.Mode.V) -> str:
        input = anki.card_rendering_pb2.StripHtmlRequest(text=text, mode=mode)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(6, 10, input))
        return output.val

    def add_or_update_deck_config_legacy(self, json: bytes) -> int:
        input = anki.generic_pb2.Json(json=json)
        output = anki.deckconfig_pb2.DeckConfigId()
        output.ParseFromString(self._run_command(7, 0, input))
        return output.dcid

    def get_deck_config(self, dcid: int) -> anki.deckconfig_pb2.DeckConfig:
        input = anki.deckconfig_pb2.DeckConfigId(dcid=dcid)
        output = anki.deckconfig_pb2.DeckConfig()
        output.ParseFromString(self._run_command(7, 1, input))
        return output

    def all_deck_config_legacy(self) -> bytes:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(7, 2, input))
        return output.json

    def get_deck_config_legacy(self, dcid: int) -> bytes:
        input = anki.deckconfig_pb2.DeckConfigId(dcid=dcid)
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(7, 3, input))
        return output.json

    def new_deck_config_legacy(self) -> bytes:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(7, 4, input))
        return output.json

    def remove_deck_config(self, dcid: int) -> anki.generic_pb2.Empty:
        input = anki.deckconfig_pb2.DeckConfigId(dcid=dcid)
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(7, 5, input))
        return output

    def get_deck_configs_for_update(self, did: int) -> anki.deckconfig_pb2.DeckConfigsForUpdate:
        input = anki.decks_pb2.DeckId(did=did)
        output = anki.deckconfig_pb2.DeckConfigsForUpdate()
        output.ParseFromString(self._run_command(7, 6, input))
        return output

    def update_deck_configs(self, input: anki.deckconfig_pb2.UpdateDeckConfigsRequest) -> anki.collection_pb2.OpChanges:
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(7, 7, input))
        return output

    def clear_unused_tags(self) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.generic_pb2.Empty()
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 0, input))
        return output

    def all_tags(self) -> Sequence[str]:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.StringList()
        output.ParseFromString(self._run_command(8, 1, input))
        return output.vals

    def remove_tags(self, val: str) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.generic_pb2.String(val=val)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 2, input))
        return output

    def set_tag_collapsed(self, *, name: str, collapsed: bool) -> anki.collection_pb2.OpChanges:
        input = anki.tags_pb2.SetTagCollapsedRequest(name=name, collapsed=collapsed)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(8, 3, input))
        return output

    def tag_tree(self) -> anki.tags_pb2.TagTreeNode:
        input = anki.generic_pb2.Empty()
        output = anki.tags_pb2.TagTreeNode()
        output.ParseFromString(self._run_command(8, 4, input))
        return output

    def reparent_tags(self, *, tags: Sequence[str], new_parent: str) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.tags_pb2.ReparentTagsRequest(tags=tags, new_parent=new_parent)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 5, input))
        return output

    def rename_tags(self, *, current_prefix: str, new_prefix: str) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.tags_pb2.RenameTagsRequest(current_prefix=current_prefix, new_prefix=new_prefix)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 6, input))
        return output

    def add_note_tags(self, *, note_ids: Sequence[int], tags: str) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.tags_pb2.NoteIdsAndTagsRequest(note_ids=note_ids, tags=tags)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 7, input))
        return output

    def remove_note_tags(self, *, note_ids: Sequence[int], tags: str) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.tags_pb2.NoteIdsAndTagsRequest(note_ids=note_ids, tags=tags)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 8, input))
        return output

    def find_and_replace_tag(self, *, note_ids: Sequence[int], search: str, replacement: str, regex: bool, match_case: bool) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.tags_pb2.FindAndReplaceTagRequest(note_ids=note_ids, search=search, replacement=replacement, regex=regex, match_case=match_case)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 9, input))
        return output

    def complete_tag(self, input: anki.tags_pb2.CompleteTagRequest) -> bytes:
        return self._run_command(8, 10, input)

    def build_search_string(self, input: anki.search_pb2.SearchNode) -> str:
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(9, 0, input))
        return output.val

    def search_cards(self, *, search: str, order: anki.search_pb2.SortOrder) -> Sequence[int]:
        input = anki.search_pb2.SearchRequest(search=search, order=order)
        output = anki.search_pb2.SearchResponse()
        output.ParseFromString(self._run_command(9, 1, input))
        return output.ids

    def search_notes(self, *, search: str, order: anki.search_pb2.SortOrder) -> Sequence[int]:
        input = anki.search_pb2.SearchRequest(search=search, order=order)
        output = anki.search_pb2.SearchResponse()
        output.ParseFromString(self._run_command(9, 2, input))
        return output.ids

    def join_search_nodes(self, *, joiner: anki.search_pb2.SearchNode.Group.Joiner.V, existing_node: anki.search_pb2.SearchNode, additional_node: anki.search_pb2.SearchNode) -> str:
        input = anki.search_pb2.JoinSearchNodesRequest(joiner=joiner, existing_node=existing_node, additional_node=additional_node)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(9, 3, input))
        return output.val

    def replace_search_node(self, *, existing_node: anki.search_pb2.SearchNode, replacement_node: anki.search_pb2.SearchNode) -> str:
        input = anki.search_pb2.ReplaceSearchNodeRequest(existing_node=existing_node, replacement_node=replacement_node)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(9, 4, input))
        return output.val

    def find_and_replace(self, *, nids: Sequence[int], search: str, replacement: str, regex: bool, match_case: bool, field_name: str) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.search_pb2.FindAndReplaceRequest(nids=nids, search=search, replacement=replacement, regex=regex, match_case=match_case, field_name=field_name)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(9, 5, input))
        return output

    def all_browser_columns(self) -> Sequence[anki.search_pb2.BrowserColumns.Column]:
        input = anki.generic_pb2.Empty()
        output = anki.search_pb2.BrowserColumns()
        output.ParseFromString(self._run_command(9, 6, input))
        return output.columns

    def browser_row_for_id(self, val: int) -> anki.search_pb2.BrowserRow:
        input = anki.generic_pb2.Int64(val=val)
        output = anki.search_pb2.BrowserRow()
        output.ParseFromString(self._run_command(9, 7, input))
        return output

    def set_active_browser_columns(self, vals: Sequence[str]) -> anki.generic_pb2.Empty:
        input = anki.generic_pb2.StringList(vals=vals)
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(9, 8, input))
        return output

    def card_stats(self, cid: int) -> bytes:
        input = anki.cards_pb2.CardId(cid=cid)
        return self._run_command(10, 0, input)

    def graphs(self, *, search: str, days: int) -> bytes:
        input = anki.stats_pb2.GraphsRequest(search=search, days=days)
        return self._run_command(10, 1, input)

    def get_graph_preferences(self) -> bytes:
        input = anki.generic_pb2.Empty()
        return self._run_command(10, 2, input)

    def set_graph_preferences(self, input: anki.stats_pb2.GraphPreferences) -> anki.generic_pb2.Empty:
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(10, 3, input))
        return output

    def check_media(self) -> anki.media_pb2.CheckMediaResponse:
        input = anki.generic_pb2.Empty()
        output = anki.media_pb2.CheckMediaResponse()
        output.ParseFromString(self._run_command(11, 0, input))
        return output

    def trash_media_files(self, fnames: Sequence[str]) -> anki.generic_pb2.Empty:
        input = anki.media_pb2.TrashMediaFilesRequest(fnames=fnames)
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(11, 1, input))
        return output

    def add_media_file(self, *, desired_name: str, data: bytes) -> str:
        input = anki.media_pb2.AddMediaFileRequest(desired_name=desired_name, data=data)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(11, 2, input))
        return output.val

    def empty_trash(self) -> anki.generic_pb2.Empty:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(11, 3, input))
        return output

    def restore_trash(self) -> anki.generic_pb2.Empty:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(11, 4, input))
        return output

    def translate_string(self, input: anki.i18n_pb2.TranslateStringRequest) -> str:
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(12, 0, input))
        return output.val

    def format_timespan(self, *, seconds: float, context: anki.i18n_pb2.FormatTimespanRequest.Context.V) -> str:
        input = anki.i18n_pb2.FormatTimespanRequest(seconds=seconds, context=context)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(12, 1, input))
        return output.val

    def i18n_resources(self, modules: Sequence[str]) -> bytes:
        input = anki.i18n_pb2.I18nResourcesRequest(modules=modules)
        output = anki.generic_pb2.Json()
        output.ParseFromString(self._run_command(12, 2, input))
        return output.json

    def open_collection(self, *, collection_path: str, media_folder_path: str, media_db_path: str, log_path: str) -> anki.generic_pb2.Empty:
        input = anki.collection_pb2.OpenCollectionRequest(collection_path=collection_path, media_folder_path=media_folder_path, media_db_path=media_db_path, log_path=log_path)
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(13, 0, input))
        return output

    def close_collection(self, downgrade_to_schema11: bool) -> anki.generic_pb2.Empty:
        input = anki.collection_pb2.CloseCollectionRequest(downgrade_to_schema11=downgrade_to_schema11)
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(13, 1, input))
        return output

    def check_database(self) -> Sequence[str]:
        input = anki.generic_pb2.Empty()
        output = anki.collection_pb2.CheckDatabaseResponse()
        output.ParseFromString(self._run_command(13, 2, input))
        return output.problems

    def get_undo_status(self) -> anki.collection_pb2.UndoStatus:
        input = anki.generic_pb2.Empty()
        output = anki.collection_pb2.UndoStatus()
        output.ParseFromString(self._run_command(13, 3, input))
        return output

    def undo(self) -> anki.collection_pb2.OpChangesAfterUndo:
        input = anki.generic_pb2.Empty()
        output = anki.collection_pb2.OpChangesAfterUndo()
        output.ParseFromString(self._run_command(13, 4, input))
        return output

    def redo(self) -> anki.collection_pb2.OpChangesAfterUndo:
        input = anki.generic_pb2.Empty()
        output = anki.collection_pb2.OpChangesAfterUndo()
        output.ParseFromString(self._run_command(13, 5, input))
        return output

    def add_custom_undo_entry(self, val: str) -> int:
        input = anki.generic_pb2.String(val=val)
        output = anki.generic_pb2.UInt32()
        output.ParseFromString(self._run_command(13, 6, input))
        return output.val

    def merge_undo_entries(self, val: int) -> anki.collection_pb2.OpChanges:
        input = anki.generic_pb2.UInt32(val=val)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(13, 7, input))
        return output

    def latest_progress(self) -> anki.collection_pb2.Progress:
        input = anki.generic_pb2.Empty()
        output = anki.collection_pb2.Progress()
        output.ParseFromString(self._run_command(13, 8, input))
        return output

    def set_wants_abort(self) -> anki.generic_pb2.Empty:
        input = anki.generic_pb2.Empty()
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(13, 9, input))
        return output

    def get_card(self, cid: int) -> anki.cards_pb2.Card:
        input = anki.cards_pb2.CardId(cid=cid)
        output = anki.cards_pb2.Card()
        output.ParseFromString(self._run_command(14, 0, input))
        return output

    def update_cards(self, *, cards: Sequence[anki.cards_pb2.Card], skip_undo_entry: bool) -> anki.collection_pb2.OpChanges:
        input = anki.cards_pb2.UpdateCardsRequest(cards=cards, skip_undo_entry=skip_undo_entry)
        output = anki.collection_pb2.OpChanges()
        output.ParseFromString(self._run_command(14, 1, input))
        return output

    def remove_cards(self, card_ids: Sequence[int]) -> anki.generic_pb2.Empty:
        input = anki.cards_pb2.RemoveCardsRequest(card_ids=card_ids)
        output = anki.generic_pb2.Empty()
        output.ParseFromString(self._run_command(14, 2, input))
        return output

    def set_deck(self, *, card_ids: Sequence[int], deck_id: int) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.cards_pb2.SetDeckRequest(card_ids=card_ids, deck_id=deck_id)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(14, 3, input))
        return output

    def set_flag(self, *, card_ids: Sequence[int], flag: int) -> anki.collection_pb2.OpChangesWithCount:
        input = anki.cards_pb2.SetFlagRequest(card_ids=card_ids, flag=flag)
        output = anki.collection_pb2.OpChangesWithCount()
        output.ParseFromString(self._run_command(14, 4, input))
        return output

    def help_page_link(self, page: anki.links_pb2.HelpPageLinkRequest.HelpPage.V) -> str:
        input = anki.links_pb2.HelpPageLinkRequest(page=page)
        output = anki.generic_pb2.String()
        output.ParseFromString(self._run_command(15, 0, input))
        return output.val
