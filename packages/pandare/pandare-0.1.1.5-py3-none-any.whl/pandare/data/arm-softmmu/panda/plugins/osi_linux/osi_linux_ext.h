#ifndef __OSI_LINUX_EXT_H__
#define __OSI_LINUX_EXT_H__
/*
 * DO NOT MODIFY. This file is automatically generated by scripts/apigen.py,
 * based on the <plugin>_int.h file in your plugin directory.
 *
 * Note: Function pointers for API calls are declared as extern.
 * The definition of the pointers is guarded by the PLUGIN_MAIN macro.
 * This plugin is defined only for the compilation unit matching the
 * name of the plugin.
 * This allows us to initialize API function pointers once, in the main
 * compilation unit, rather than in every compilation unit.
 */
#include <dlfcn.h>
#include "panda/plugin.h"

typedef char *(*osi_linux_fd_to_filename_t)(CPUState *env, OsiProc *p, int fd);
extern osi_linux_fd_to_filename_t __osi_linux_fd_to_filename;
#ifdef PLUGIN_MAIN
osi_linux_fd_to_filename_t __osi_linux_fd_to_filename = NULL;
#endif
static inline char * osi_linux_fd_to_filename(CPUState *env, OsiProc *p, int fd);
static inline char * osi_linux_fd_to_filename(CPUState *env, OsiProc *p, int fd) {
    assert(__osi_linux_fd_to_filename);
    return __osi_linux_fd_to_filename(env,p,fd);
}

typedef unsigned long long(*osi_linux_fd_to_pos_t)(CPUState *env, OsiProc *p, int fd);
extern osi_linux_fd_to_pos_t __osi_linux_fd_to_pos;
#ifdef PLUGIN_MAIN
osi_linux_fd_to_pos_t __osi_linux_fd_to_pos = NULL;
#endif
static inline unsigned long long osi_linux_fd_to_pos(CPUState *env, OsiProc *p, int fd);
static inline unsigned long long osi_linux_fd_to_pos(CPUState *env, OsiProc *p, int fd) {
    assert(__osi_linux_fd_to_pos);
    return __osi_linux_fd_to_pos(env,p,fd);
}

typedef target_ptr_t(*ext_get_file_struct_ptr_t)(CPUState *env, target_ptr_t task_struct, int fd);
extern ext_get_file_struct_ptr_t __ext_get_file_struct_ptr;
#ifdef PLUGIN_MAIN
ext_get_file_struct_ptr_t __ext_get_file_struct_ptr = NULL;
#endif
static inline target_ptr_t ext_get_file_struct_ptr(CPUState *env, target_ptr_t task_struct, int fd);
static inline target_ptr_t ext_get_file_struct_ptr(CPUState *env, target_ptr_t task_struct, int fd) {
    assert(__ext_get_file_struct_ptr);
    return __ext_get_file_struct_ptr(env,task_struct,fd);
}

typedef target_ptr_t(*ext_get_file_dentry_t)(CPUState *env, target_ptr_t file_struct);
extern ext_get_file_dentry_t __ext_get_file_dentry;
#ifdef PLUGIN_MAIN
ext_get_file_dentry_t __ext_get_file_dentry = NULL;
#endif
static inline target_ptr_t ext_get_file_dentry(CPUState *env, target_ptr_t file_struct);
static inline target_ptr_t ext_get_file_dentry(CPUState *env, target_ptr_t file_struct) {
    assert(__ext_get_file_dentry);
    return __ext_get_file_dentry(env,file_struct);
}

bool init_osi_linux_api(void);

#ifdef PLUGIN_MAIN
#define API_PLUGIN_NAME "osi_linux"
#define IMPORT_PPP(module, func_name) { \
    __##func_name = (func_name##_t) dlsym(module, #func_name); \
    char *err = dlerror(); \
    if (err) { \
        printf("Couldn't find %s function in library %s.\n", #func_name, API_PLUGIN_NAME); \
        printf("Error: %s\n", err); \
        return false; \
    } \
}
bool init_osi_linux_api(void) {
    void *module = panda_get_plugin_by_name(API_PLUGIN_NAME);
    if (!module) {
        fprintf(stderr, "Couldn't load %s plugin: %s\n", API_PLUGIN_NAME, dlerror());
        return false;
    }
    IMPORT_PPP(module, osi_linux_fd_to_filename)
    IMPORT_PPP(module, osi_linux_fd_to_pos)
    IMPORT_PPP(module, ext_get_file_struct_ptr)
    IMPORT_PPP(module, ext_get_file_dentry)
    return true;
}
#undef API_PLUGIN_NAME
#undef IMPORT_PPP
#endif

#endif
